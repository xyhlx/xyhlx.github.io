<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>RabbitMQ入门</title>
    <link href="/article/bae9a0d2/"/>
    <url>/article/bae9a0d2/</url>
    
    <content type="html"><![CDATA[<h1 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><h1 id="1-初识MQ"><a href="#1-初识MQ" class="headerlink" title="1.初识MQ"></a>1.初识MQ</h1><h2 id="1-1-同步和异步通讯"><a href="#1-1-同步和异步通讯" class="headerlink" title="1.1.同步和异步通讯"></a>1.1.同步和异步通讯</h2><p>微服务间通讯有同步和异步两种方式：</p><p>同步通讯：就像打电话，需要实时响应。</p><p>异步通讯：就像发邮件，不需要马上回复。</p><p>两种方式各有优劣，打电话可以立即得到响应，但是你却不能跟多个人同时通话。发送邮件可以同时与多个人收发邮件，但是往往响应会有延迟。</p><h3 id="1-1-1-同步通讯"><a href="#1-1-1-同步通讯" class="headerlink" title="1.1.1.同步通讯"></a>1.1.1.同步通讯</h3><p>我们之前学习的Feign调用就属于同步方式，虽然调用可以实时得到结果，但存在下面的问题：</p><p>总结：</p><p>同步调用的优点：</p><ul><li>时效性较强，可以立即得到结果</li></ul><p>同步调用的问题：</p><ul><li>耦合度高</li><li>性能和吞吐能力下降</li><li>有额外的资源消耗</li><li>有级联失败问题</li></ul><h3 id="1-1-2-异步通讯"><a href="#1-1-2-异步通讯" class="headerlink" title="1.1.2.异步通讯"></a>1.1.2.异步通讯</h3><p>异步调用则可以避免上述问题：</p><p>我们以购买商品为例，用户支付后需要调用订单服务完成订单状态修改，调用物流服务，从仓库分配响应的库存并准备发货。</p><p>在事件模式中，支付服务是事件发布者（publisher），在支付完成后只需要发布一个支付成功的事件（event），事件中带上订单id。</p><p>订单服务和物流服务是事件订阅者（Consumer），订阅支付成功的事件，监听到事件后完成自己业务即可。</p><p>为了解除事件发布者与订阅者之间的耦合，两者并不是直接通信，而是有一个中间人（Broker）。发布者发布事件到Broker，不关心谁来订阅事件。订阅者从Broker订阅事件，不关心谁发来的消息。</p><p>Broker 是一个像数据总线一样的东西，所有的服务要接收数据和发送数据都发到这个总线上，这个总线就像协议一样，让服务间的通讯变得标准和可控。</p><p>好处：</p><ul><li><p>吞吐量提升：无需等待订阅者处理完成，响应更快速</p></li><li><p>故障隔离：服务没有直接调用，不存在级联失败问题</p></li><li><p>调用间没有阻塞，不会造成无效的资源占用</p></li><li><p>耦合度极低，每个服务都可以灵活插拔，可替换</p></li><li><p>流量削峰：不管发布事件的流量波动多大，都由Broker接收，订阅者可以按照自己的速度去处理事件</p></li></ul><p>缺点：</p><ul><li>架构复杂了，业务没有明显的流程线，不好管理</li><li>需要依赖于Broker的可靠、安全、性能</li></ul><p>好在现在开源软件或云平台上 Broker 的软件是非常成熟的，比较常见的一种就是我们今天要学习的MQ技术。</p><h2 id="1-2-技术对比："><a href="#1-2-技术对比：" class="headerlink" title="1.2.技术对比："></a>1.2.技术对比：</h2><p>MQ，中文是消息队列（MessageQueue），字面来看就是存放消息的队列。也就是事件驱动架构中的Broker。</p><p>比较常见的MQ实现：</p><ul><li>ActiveMQ</li><li>RabbitMQ</li><li>RocketMQ</li><li>Kafka</li></ul><p>几种常见MQ的对比：</p><table><thead><tr><th></th><th><strong>RabbitMQ</strong></th><th><strong>ActiveMQ</strong></th><th><strong>RocketMQ</strong></th><th><strong>Kafka</strong></th></tr></thead><tbody><tr><td>公司&#x2F;社区</td><td>Rabbit</td><td>Apache</td><td>阿里</td><td>Apache</td></tr><tr><td>开发语言</td><td>Erlang</td><td>Java</td><td>Java</td><td>Scala&amp;Java</td></tr><tr><td>协议支持</td><td>AMQP，XMPP，SMTP，STOMP</td><td>OpenWire,STOMP，REST,XMPP,AMQP</td><td>自定义协议</td><td>自定义协议</td></tr><tr><td>可用性</td><td>高</td><td>一般</td><td>高</td><td>高</td></tr><tr><td>单机吞吐量</td><td>一般</td><td>差</td><td>高</td><td>非常高</td></tr><tr><td>消息延迟</td><td>微秒级</td><td>毫秒级</td><td>毫秒级</td><td>毫秒以内</td></tr><tr><td>消息可靠性</td><td>高</td><td>一般</td><td>高</td><td>一般</td></tr></tbody></table><p>追求可用性：Kafka、 RocketMQ 、RabbitMQ</p><p>追求可靠性：RabbitMQ、RocketMQ</p><p>追求吞吐能力：RocketMQ、Kafka</p><p>追求消息低延迟：RabbitMQ、Kafka</p><h1 id="2-快速入门"><a href="#2-快速入门" class="headerlink" title="2.快速入门"></a>2.快速入门</h1><h2 id="2-1-安装RabbitMQ"><a href="#2-1-安装RabbitMQ" class="headerlink" title="2.1.安装RabbitMQ"></a>2.1.安装RabbitMQ</h2><p>RabbitMQ中的一些角色：</p><ul><li>publisher：生产者</li><li>consumer：消费者</li><li>exchange个：交换机，负责消息路由</li><li>queue：队列，存储消息</li><li>virtualHost：虚拟主机，隔离不同租户的exchange、queue、消息的隔离</li></ul><h2 id="2-2-RabbitMQ消息模型"><a href="#2-2-RabbitMQ消息模型" class="headerlink" title="2.2.RabbitMQ消息模型"></a>2.2.RabbitMQ消息模型</h2><p>RabbitMQ官方提供了5个不同的Demo示例，对应了不同的消息模型：</p><h2 id="2-3-导入Demo工程"><a href="#2-3-导入Demo工程" class="headerlink" title="2.3.导入Demo工程"></a>2.3.导入Demo工程</h2><p>包括三部分：</p><ul><li>mq-demo：父工程，管理项目依赖</li><li>publisher：消息的发送者</li><li>consumer：消息的消费者</li></ul><h2 id="2-4-入门案例"><a href="#2-4-入门案例" class="headerlink" title="2.4.入门案例"></a>2.4.入门案例</h2><p>官方的HelloWorld是基于最基础的消息队列模型来实现的，只包括三个角色：</p><ul><li>publisher：消息发布者，将消息发送到队列queue</li><li>queue：消息队列，负责接受并缓存消息</li><li>consumer：订阅队列，处理队列中的消息</li></ul><h3 id="2-4-1-publisher实现"><a href="#2-4-1-publisher实现" class="headerlink" title="2.4.1.publisher实现"></a>2.4.1.publisher实现</h3><p>思路：</p><ul><li>建立连接</li><li>创建Channel</li><li>声明队列</li><li>发送消息</li><li>关闭连接和channel</li></ul><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.mq.helloworld;<br><br><span class="hljs-keyword">import</span> com.rabbitmq.client.Channel;<br><span class="hljs-keyword">import</span> com.rabbitmq.client.Connection;<br><span class="hljs-keyword">import</span> com.rabbitmq.client.ConnectionFactory;<br><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeoutException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PublisherTest</span> &#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSendMessage</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException, TimeoutException &#123;<br>        <span class="hljs-comment">// 1.建立连接</span><br>        <span class="hljs-type">ConnectionFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConnectionFactory</span>();<br>        <span class="hljs-comment">// 1.1.设置连接参数，分别是：主机名、端口号、vhost、用户名、密码</span><br>        factory.setHost(<span class="hljs-string">&quot;192.168.150.101&quot;</span>);<br>        factory.setPort(<span class="hljs-number">5672</span>);<br>        factory.setVirtualHost(<span class="hljs-string">&quot;/&quot;</span>);<br>        factory.setUsername(<span class="hljs-string">&quot;itcast&quot;</span>);<br>        factory.setPassword(<span class="hljs-string">&quot;123321&quot;</span>);<br>        <span class="hljs-comment">// 1.2.建立连接</span><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> factory.newConnection();<br><br>        <span class="hljs-comment">// 2.创建通道Channel</span><br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connection.createChannel();<br><br>        <span class="hljs-comment">// 3.创建队列</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">queueName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;simple.queue&quot;</span>;<br>        channel.queueDeclare(queueName, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);<br><br>        <span class="hljs-comment">// 4.发送消息</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello, rabbitmq!&quot;</span>;<br>        channel.basicPublish(<span class="hljs-string">&quot;&quot;</span>, queueName, <span class="hljs-literal">null</span>, message.getBytes());<br>        System.out.println(<span class="hljs-string">&quot;发送消息成功：【&quot;</span> + message + <span class="hljs-string">&quot;】&quot;</span>);<br><br>        <span class="hljs-comment">// 5.关闭通道和连接</span><br>        channel.close();<br>        connection.close();<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-4-2-consumer实现"><a href="#2-4-2-consumer实现" class="headerlink" title="2.4.2.consumer实现"></a>2.4.2.consumer实现</h3><p>代码思路：</p><ul><li>建立连接</li><li>创建Channel</li><li>声明队列</li><li>订阅消息</li></ul><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.mq.helloworld;<br><br><span class="hljs-keyword">import</span> com.rabbitmq.client.*;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeoutException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConsumerTest</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, TimeoutException &#123;<br>        <span class="hljs-comment">// 1.建立连接</span><br>        <span class="hljs-type">ConnectionFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConnectionFactory</span>();<br>        <span class="hljs-comment">// 1.1.设置连接参数，分别是：主机名、端口号、vhost、用户名、密码</span><br>        factory.setHost(<span class="hljs-string">&quot;192.168.150.101&quot;</span>);<br>        factory.setPort(<span class="hljs-number">5672</span>);<br>        factory.setVirtualHost(<span class="hljs-string">&quot;/&quot;</span>);<br>        factory.setUsername(<span class="hljs-string">&quot;itcast&quot;</span>);<br>        factory.setPassword(<span class="hljs-string">&quot;123321&quot;</span>);<br>        <span class="hljs-comment">// 1.2.建立连接</span><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> factory.newConnection();<br><br>        <span class="hljs-comment">// 2.创建通道Channel</span><br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connection.createChannel();<br><br>        <span class="hljs-comment">// 3.创建队列</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">queueName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;simple.queue&quot;</span>;<br>        channel.queueDeclare(queueName, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);<br><br>        <span class="hljs-comment">// 4.订阅消息</span><br>        channel.basicConsume(queueName, <span class="hljs-literal">true</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultConsumer</span>(channel)&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope,</span><br><span class="hljs-params">                                       AMQP.BasicProperties properties, <span class="hljs-type">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>                <span class="hljs-comment">// 5.处理消息</span><br>                <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(body);<br>                System.out.println(<span class="hljs-string">&quot;接收到消息：【&quot;</span> + message + <span class="hljs-string">&quot;】&quot;</span>);<br>            &#125;<br>        &#125;);<br>        System.out.println(<span class="hljs-string">&quot;等待接收消息。。。。&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-5-总结"><a href="#2-5-总结" class="headerlink" title="2.5.总结"></a>2.5.总结</h2><p>基本消息队列的消息发送流程：</p><ol><li><p>建立connection</p></li><li><p>创建channel</p></li><li><p>利用channel声明队列</p></li><li><p>利用channel向队列发送消息</p></li></ol><p>基本消息队列的消息接收流程：</p><ol><li><p>建立connection</p></li><li><p>创建channel</p></li><li><p>利用channel声明队列</p></li><li><p>定义consumer的消费行为handleDelivery()</p></li><li><p>利用channel将消费者与队列绑定</p></li></ol><h1 id="3-SpringAMQP"><a href="#3-SpringAMQP" class="headerlink" title="3.SpringAMQP"></a>3.SpringAMQP</h1><p>SpringAMQP是基于RabbitMQ封装的一套模板，并且还利用SpringBoot对其实现了自动装配，使用起来非常方便。</p><p>SpringAmqp的官方地址：<a href="https://spring.io/projects/spring-amqp">https://spring.io/projects/spring-amqp</a></p><p>SpringAMQP提供了三个功能：</p><ul><li>自动声明队列、交换机及其绑定关系</li><li>基于注解的监听器模式，异步接收消息</li><li>封装了RabbitTemplate工具，用于发送消息</li></ul><h2 id="3-1-Basic-Queue-简单队列模型"><a href="#3-1-Basic-Queue-简单队列模型" class="headerlink" title="3.1.Basic Queue 简单队列模型"></a>3.1.Basic Queue 简单队列模型</h2><p>在父工程mq-demo中引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--AMQP依赖，包含RabbitMQ--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="3-1-1-消息发送"><a href="#3-1-1-消息发送" class="headerlink" title="3.1.1.消息发送"></a>3.1.1.消息发送</h3><p>首先配置MQ地址，在publisher服务的application.yml中添加配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">rabbitmq:</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.150</span><span class="hljs-number">.101</span> <span class="hljs-comment"># 主机名</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">5672</span> <span class="hljs-comment"># 端口</span><br>    <span class="hljs-attr">virtual-host:</span> <span class="hljs-string">/</span> <span class="hljs-comment"># 虚拟主机</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">itcast</span> <span class="hljs-comment"># 用户名</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-number">123321</span> <span class="hljs-comment"># 密码</span><br></code></pre></td></tr></table></figure><p>然后在publisher服务中编写测试类SpringAmqpTest，并利用RabbitTemplate实现消息发送：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.mq.spring;<br><br><span class="hljs-keyword">import</span> org.junit.Test;<br><span class="hljs-keyword">import</span> org.junit.runner.RunWith;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.boot.test.context.SpringBootTest;<br><span class="hljs-keyword">import</span> org.springframework.test.context.junit4.SpringRunner;<br><br><span class="hljs-meta">@RunWith(SpringRunner.class)</span><br><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringAmqpTest</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSimpleQueue</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 队列名称</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">queueName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;simple.queue&quot;</span>;<br>        <span class="hljs-comment">// 消息</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello, spring amqp!&quot;</span>;<br>        <span class="hljs-comment">// 发送消息</span><br>        rabbitTemplate.convertAndSend(queueName, message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-1-2-消息接收"><a href="#3-1-2-消息接收" class="headerlink" title="3.1.2.消息接收"></a>3.1.2.消息接收</h3><p>首先配置MQ地址，在consumer服务的application.yml中添加配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">rabbitmq:</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.150</span><span class="hljs-number">.101</span> <span class="hljs-comment"># 主机名</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">5672</span> <span class="hljs-comment"># 端口</span><br>    <span class="hljs-attr">virtual-host:</span> <span class="hljs-string">/</span> <span class="hljs-comment"># 虚拟主机</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">itcast</span> <span class="hljs-comment"># 用户名</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-number">123321</span> <span class="hljs-comment"># 密码</span><br></code></pre></td></tr></table></figure><p>然后在consumer服务的<code>cn.itcast.mq.listener</code>包中新建一个类SpringRabbitListener，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.mq.listener;<br><br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringRabbitListener</span> &#123;<br><br>    <span class="hljs-meta">@RabbitListener(queues = &quot;simple.queue&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">listenSimpleQueueMessage</span><span class="hljs-params">(String msg)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        System.out.println(<span class="hljs-string">&quot;spring 消费者接收到消息：【&quot;</span> + msg + <span class="hljs-string">&quot;】&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-1-3-测试"><a href="#3-1-3-测试" class="headerlink" title="3.1.3.测试"></a>3.1.3.测试</h3><p>启动consumer服务，然后在publisher服务中运行测试代码，发送MQ消息</p><h2 id="3-2-WorkQueue"><a href="#3-2-WorkQueue" class="headerlink" title="3.2.WorkQueue"></a>3.2.WorkQueue</h2><p>Work queues，也被称为（Task queues），任务模型。简单来说就是<strong>让多个消费者绑定到一个队列，共同消费队列中的消息</strong>。</p><p>当消息处理比较耗时的时候，可能生产消息的速度会远远大于消息的消费速度。长此以往，消息就会堆积越来越多，无法及时处理。</p><p>此时就可以使用work 模型，多个消费者共同处理消息处理，速度就能大大提高了。</p><h3 id="3-2-1-消息发送"><a href="#3-2-1-消息发送" class="headerlink" title="3.2.1.消息发送"></a>3.2.1.消息发送</h3><p>这次我们循环发送，模拟大量消息堆积现象。</p><p>在publisher服务中的SpringAmqpTest类中添加一个测试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * workQueue</span><br><span class="hljs-comment">     * 向队列中不停发送消息，模拟消息堆积。</span><br><span class="hljs-comment">     */</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testWorkQueue</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-comment">// 队列名称</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">queueName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;simple.queue&quot;</span>;<br>    <span class="hljs-comment">// 消息</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello, message_&quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50</span>; i++) &#123;<br>        <span class="hljs-comment">// 发送消息</span><br>        rabbitTemplate.convertAndSend(queueName, message + i);<br>        Thread.sleep(<span class="hljs-number">20</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-2-消息接收"><a href="#3-2-2-消息接收" class="headerlink" title="3.2.2.消息接收"></a>3.2.2.消息接收</h3><p>要模拟多个消费者绑定同一个队列，我们在consumer服务的SpringRabbitListener中添加2个新的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RabbitListener(queues = &quot;simple.queue&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">listenWorkQueue1</span><span class="hljs-params">(String msg)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    System.out.println(<span class="hljs-string">&quot;消费者1接收到消息：【&quot;</span> + msg + <span class="hljs-string">&quot;】&quot;</span> + LocalTime.now());<br>    Thread.sleep(<span class="hljs-number">20</span>);<br>&#125;<br><br><span class="hljs-meta">@RabbitListener(queues = &quot;simple.queue&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">listenWorkQueue2</span><span class="hljs-params">(String msg)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    System.err.println(<span class="hljs-string">&quot;消费者2........接收到消息：【&quot;</span> + msg + <span class="hljs-string">&quot;】&quot;</span> + LocalTime.now());<br>    Thread.sleep(<span class="hljs-number">200</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>注意到这个消费者sleep了1000秒，模拟任务耗时。</p><h3 id="3-2-3-测试"><a href="#3-2-3-测试" class="headerlink" title="3.2.3.测试"></a>3.2.3.测试</h3><p>启动ConsumerApplication后，在执行publisher服务中刚刚编写的发送测试方法testWorkQueue。</p><p>可以看到消费者1很快完成了自己的25条消息。消费者2却在缓慢的处理自己的25条消息。</p><p>也就是说消息是平均分配给每个消费者，并没有考虑到消费者的处理能力。这样显然是有问题的。</p><h3 id="3-2-4-能者多劳"><a href="#3-2-4-能者多劳" class="headerlink" title="3.2.4.能者多劳"></a>3.2.4.能者多劳</h3><p>在spring中有一个简单的配置，可以解决这个问题。我们修改consumer服务的application.yml文件，添加配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">rabbitmq:</span><br>    <span class="hljs-attr">listener:</span><br>      <span class="hljs-attr">simple:</span><br>        <span class="hljs-attr">prefetch:</span> <span class="hljs-number">1</span> <span class="hljs-comment"># 每次只能获取一条消息，处理完成才能获取下一个消息</span><br></code></pre></td></tr></table></figure><h3 id="3-2-5-总结"><a href="#3-2-5-总结" class="headerlink" title="3.2.5.总结"></a>3.2.5.总结</h3><p>Work模型的使用：</p><ul><li>多个消费者绑定到一个队列，同一条消息只会被一个消费者处理</li><li>通过设置prefetch来控制消费者预取的消息数量</li></ul><h2 id="3-3-发布-订阅"><a href="#3-3-发布-订阅" class="headerlink" title="3.3.发布&#x2F;订阅"></a>3.3.发布&#x2F;订阅</h2><ul><li>Publisher：生产者，也就是要发送消息的程序，但是不再发送到队列中，而是发给X（交换机）</li><li>Exchange：交换机，图中的X。一方面，接收生产者发送的消息。另一方面，知道如何处理消息，例如递交给某个特别队列、递交给所有队列、或是将消息丢弃。到底如何操作，取决于Exchange的类型。Exchange有以下3种类型：<ul><li>Fanout：广播，将消息交给所有绑定到交换机的队列</li><li>Direct：定向，把消息交给符合指定routing key 的队列</li><li>Topic：通配符，把消息交给符合routing pattern（路由模式） 的队列</li></ul></li><li>Consumer：消费者，与以前一样，订阅队列，没有变化</li><li>Queue：消息队列也与以前一样，接收消息、缓存消息。</li></ul><p><strong>Exchange（交换机）只负责转发消息，不具备存储消息的能力</strong>，因此如果没有任何队列与Exchange绑定，或者没有符合路由规则的队列，那么消息会丢失！</p><h2 id="3-4-Fanout"><a href="#3-4-Fanout" class="headerlink" title="3.4.Fanout"></a>3.4.Fanout</h2><p>Fanout，英文翻译是扇出，我觉得在MQ中叫广播更合适。</p><p>在广播模式下，消息发送流程是这样的：</p><ul><li>1）  可以有多个队列</li><li>2）  每个队列都要绑定到Exchange（交换机）</li><li>3）  生产者发送的消息，只能发送到交换机，交换机来决定要发给哪个队列，生产者无法决定</li><li>4）  交换机把消息发送给绑定过的所有队列</li><li>5）  订阅队列的消费者都能拿到消息</li></ul><p>我们的计划是这样的：</p><ul><li>创建一个交换机 itcast.fanout，类型是Fanout</li><li>创建两个队列fanout.queue1和fanout.queue2，绑定到交换机itcast.fanout</li></ul><h3 id="3-4-1-声明队列和交换机"><a href="#3-4-1-声明队列和交换机" class="headerlink" title="3.4.1.声明队列和交换机"></a>3.4.1.声明队列和交换机</h3><p>Spring提供了一个接口Exchange，来表示所有不同类型的交换机：</p><p>在consumer中创建一个类，声明队列和交换机：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.mq.config;<br><br><span class="hljs-keyword">import</span> org.springframework.amqp.core.Binding;<br><span class="hljs-keyword">import</span> org.springframework.amqp.core.BindingBuilder;<br><span class="hljs-keyword">import</span> org.springframework.amqp.core.FanoutExchange;<br><span class="hljs-keyword">import</span> org.springframework.amqp.core.Queue;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FanoutConfig</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 声明交换机</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> Fanout类型交换机</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> FanoutExchange <span class="hljs-title function_">fanoutExchange</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FanoutExchange</span>(<span class="hljs-string">&quot;itcast.fanout&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 第1个队列</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">fanoutQueue1</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Queue</span>(<span class="hljs-string">&quot;fanout.queue1&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 绑定队列和交换机</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Binding <span class="hljs-title function_">bindingQueue1</span><span class="hljs-params">(Queue fanoutQueue1, FanoutExchange fanoutExchange)</span>&#123;<br>        <span class="hljs-keyword">return</span> BindingBuilder.bind(fanoutQueue1).to(fanoutExchange);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 第2个队列</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">fanoutQueue2</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Queue</span>(<span class="hljs-string">&quot;fanout.queue2&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 绑定队列和交换机</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Binding <span class="hljs-title function_">bindingQueue2</span><span class="hljs-params">(Queue fanoutQueue2, FanoutExchange fanoutExchange)</span>&#123;<br>        <span class="hljs-keyword">return</span> BindingBuilder.bind(fanoutQueue2).to(fanoutExchange);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-4-2-消息发送"><a href="#3-4-2-消息发送" class="headerlink" title="3.4.2.消息发送"></a>3.4.2.消息发送</h3><p>在publisher服务的SpringAmqpTest类中添加测试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testFanoutExchange</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 队列名称</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">exchangeName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;itcast.fanout&quot;</span>;<br>    <span class="hljs-comment">// 消息</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello, everyone!&quot;</span>;<br>    rabbitTemplate.convertAndSend(exchangeName, <span class="hljs-string">&quot;&quot;</span>, message);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-4-3-消息接收"><a href="#3-4-3-消息接收" class="headerlink" title="3.4.3.消息接收"></a>3.4.3.消息接收</h3><p>在consumer服务的SpringRabbitListener中添加两个方法，作为消费者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RabbitListener(queues = &quot;fanout.queue1&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">listenFanoutQueue1</span><span class="hljs-params">(String msg)</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;消费者1接收到Fanout消息：【&quot;</span> + msg + <span class="hljs-string">&quot;】&quot;</span>);<br>&#125;<br><br><span class="hljs-meta">@RabbitListener(queues = &quot;fanout.queue2&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">listenFanoutQueue2</span><span class="hljs-params">(String msg)</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;消费者2接收到Fanout消息：【&quot;</span> + msg + <span class="hljs-string">&quot;】&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-4-4-总结"><a href="#3-4-4-总结" class="headerlink" title="3.4.4.总结"></a>3.4.4.总结</h3><p>交换机的作用是什么？</p><ul><li>接收publisher发送的消息</li><li>将消息按照规则路由到与之绑定的队列</li><li>不能缓存消息，路由失败，消息丢失</li><li>FanoutExchange的会将消息路由到每个绑定的队列</li></ul><p>声明队列、交换机、绑定关系的Bean是什么？</p><ul><li>Queue</li><li>FanoutExchange</li><li>Binding</li></ul><h2 id="3-5-Direct"><a href="#3-5-Direct" class="headerlink" title="3.5.Direct"></a>3.5.Direct</h2><p>在Fanout模式中，一条消息，会被所有订阅的队列都消费。但是，在某些场景下，我们希望不同的消息被不同的队列消费。这时就要用到Direct类型的Exchange。</p><p> 在Direct模型下：</p><ul><li>队列与交换机的绑定，不能是任意绑定了，而是要指定一个<code>RoutingKey</code>（路由key）</li><li>消息的发送方在 向 Exchange发送消息时，也必须指定消息的 <code>RoutingKey</code>。</li><li>Exchange不再把消息交给每一个绑定的队列，而是根据消息的<code>Routing Key</code>进行判断，只有队列的<code>Routingkey</code>与消息的 <code>Routing key</code>完全一致，才会接收到消息</li></ul><p><strong>案例需求如下</strong>：</p><ol><li><p>利用@RabbitListener声明Exchange、Queue、RoutingKey</p></li><li><p>在consumer服务中，编写两个消费者方法，分别监听direct.queue1和direct.queue2</p></li><li><p>在publisher中编写测试方法，向itcast. direct发送消息</p></li></ol><h3 id="3-5-1-基于注解声明队列和交换机"><a href="#3-5-1-基于注解声明队列和交换机" class="headerlink" title="3.5.1.基于注解声明队列和交换机"></a>3.5.1.基于注解声明队列和交换机</h3><p>基于@Bean的方式声明队列和交换机比较麻烦，Spring还提供了基于注解方式来声明。</p><p>在consumer的SpringRabbitListener中添加两个消费者，同时基于注解来声明队列和交换机：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RabbitListener(bindings = @QueueBinding(</span><br><span class="hljs-meta">    value = @Queue(name = &quot;direct.queue1&quot;),</span><br><span class="hljs-meta">    exchange = @Exchange(name = &quot;itcast.direct&quot;, type = ExchangeTypes.DIRECT),</span><br><span class="hljs-meta">    key = &#123;&quot;red&quot;, &quot;blue&quot;&#125;</span><br><span class="hljs-meta">))</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">listenDirectQueue1</span><span class="hljs-params">(String msg)</span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;消费者接收到direct.queue1的消息：【&quot;</span> + msg + <span class="hljs-string">&quot;】&quot;</span>);<br>&#125;<br><br><span class="hljs-meta">@RabbitListener(bindings = @QueueBinding(</span><br><span class="hljs-meta">    value = @Queue(name = &quot;direct.queue2&quot;),</span><br><span class="hljs-meta">    exchange = @Exchange(name = &quot;itcast.direct&quot;, type = ExchangeTypes.DIRECT),</span><br><span class="hljs-meta">    key = &#123;&quot;red&quot;, &quot;yellow&quot;&#125;</span><br><span class="hljs-meta">))</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">listenDirectQueue2</span><span class="hljs-params">(String msg)</span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;消费者接收到direct.queue2的消息：【&quot;</span> + msg + <span class="hljs-string">&quot;】&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-5-2-消息发送"><a href="#3-5-2-消息发送" class="headerlink" title="3.5.2.消息发送"></a>3.5.2.消息发送</h3><p>在publisher服务的SpringAmqpTest类中添加测试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSendDirectExchange</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 交换机名称</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">exchangeName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;itcast.direct&quot;</span>;<br>    <span class="hljs-comment">// 消息</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;红色警报！日本乱排核废水，导致海洋生物变异，惊现哥斯拉！&quot;</span>;<br>    <span class="hljs-comment">// 发送消息</span><br>    rabbitTemplate.convertAndSend(exchangeName, <span class="hljs-string">&quot;red&quot;</span>, message);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-5-3-总结"><a href="#3-5-3-总结" class="headerlink" title="3.5.3.总结"></a>3.5.3.总结</h3><p>描述下Direct交换机与Fanout交换机的差异？</p><ul><li>Fanout交换机将消息路由给每一个与之绑定的队列</li><li>Direct交换机根据RoutingKey判断路由给哪个队列</li><li>如果多个队列具有相同的RoutingKey，则与Fanout功能类似</li></ul><p>基于@RabbitListener注解声明队列和交换机有哪些常见注解？</p><ul><li>@Queue</li><li>@Exchange</li></ul><h2 id="3-6-Topic"><a href="#3-6-Topic" class="headerlink" title="3.6.Topic"></a>3.6.Topic</h2><h3 id="3-6-1-说明"><a href="#3-6-1-说明" class="headerlink" title="3.6.1.说明"></a>3.6.1.说明</h3><p><code>Topic</code>类型的<code>Exchange</code>与<code>Direct</code>相比，都是可以根据<code>RoutingKey</code>把消息路由到不同的队列。只不过<code>Topic</code>类型<code>Exchange</code>可以让队列在绑定<code>Routing key</code> 的时候使用通配符！</p><p><code>Routingkey</code> 一般都是有一个或多个单词组成，多个单词之间以”.”分割，例如： <code>item.insert</code></p><p> 通配符规则：</p><p><code>#</code>：匹配一个或多个词</p><p><code>*</code>：匹配不多不少恰好1个词</p><p>举例：</p><p><code>item.#</code>：能够匹配<code>item.spu.insert</code> 或者 <code>item.spu</code></p><p><code>item.*</code>：只能匹配<code>item.spu</code></p><p>​     </p><p>解释：</p><ul><li>Queue1：绑定的是<code>china.#</code> ，因此凡是以 <code>china.</code>开头的<code>routing key</code> 都会被匹配到。包括china.news和china.weather</li><li>Queue2：绑定的是<code>#.news</code> ，因此凡是以 <code>.news</code>结尾的 <code>routing key</code> 都会被匹配。包括china.news和japan.news</li></ul><p>案例需求：</p><p>实现思路如下：</p><ol><li><p>并利用@RabbitListener声明Exchange、Queue、RoutingKey</p></li><li><p>在consumer服务中，编写两个消费者方法，分别监听topic.queue1和topic.queue2</p></li><li><p>在publisher中编写测试方法，向itcast. topic发送消息</p></li></ol><h3 id="3-6-2-消息发送"><a href="#3-6-2-消息发送" class="headerlink" title="3.6.2.消息发送"></a>3.6.2.消息发送</h3><p>在publisher服务的SpringAmqpTest类中添加测试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * topicExchange</span><br><span class="hljs-comment">     */</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSendTopicExchange</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 交换机名称</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">exchangeName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;itcast.topic&quot;</span>;<br>    <span class="hljs-comment">// 消息</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;喜报！孙悟空大战哥斯拉，胜!&quot;</span>;<br>    <span class="hljs-comment">// 发送消息</span><br>    rabbitTemplate.convertAndSend(exchangeName, <span class="hljs-string">&quot;china.news&quot;</span>, message);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-6-3-消息接收"><a href="#3-6-3-消息接收" class="headerlink" title="3.6.3.消息接收"></a>3.6.3.消息接收</h3><p>在consumer服务的SpringRabbitListener中添加方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RabbitListener(bindings = @QueueBinding(</span><br><span class="hljs-meta">    value = @Queue(name = &quot;topic.queue1&quot;),</span><br><span class="hljs-meta">    exchange = @Exchange(name = &quot;itcast.topic&quot;, type = ExchangeTypes.TOPIC),</span><br><span class="hljs-meta">    key = &quot;china.#&quot;</span><br><span class="hljs-meta">))</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">listenTopicQueue1</span><span class="hljs-params">(String msg)</span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;消费者接收到topic.queue1的消息：【&quot;</span> + msg + <span class="hljs-string">&quot;】&quot;</span>);<br>&#125;<br><br><span class="hljs-meta">@RabbitListener(bindings = @QueueBinding(</span><br><span class="hljs-meta">    value = @Queue(name = &quot;topic.queue2&quot;),</span><br><span class="hljs-meta">    exchange = @Exchange(name = &quot;itcast.topic&quot;, type = ExchangeTypes.TOPIC),</span><br><span class="hljs-meta">    key = &quot;#.news&quot;</span><br><span class="hljs-meta">))</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">listenTopicQueue2</span><span class="hljs-params">(String msg)</span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;消费者接收到topic.queue2的消息：【&quot;</span> + msg + <span class="hljs-string">&quot;】&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-6-4-总结"><a href="#3-6-4-总结" class="headerlink" title="3.6.4.总结"></a>3.6.4.总结</h3><p>描述下Direct交换机与Topic交换机的差异？</p><ul><li>Topic交换机接收的消息RoutingKey必须是多个单词，以 <code>**.**</code> 分割</li><li>Topic交换机与队列绑定时的bindingKey可以指定通配符</li><li><code>#</code>：代表0个或多个词</li><li><code>*</code>：代表1个词</li></ul><h2 id="3-7-消息转换器"><a href="#3-7-消息转换器" class="headerlink" title="3.7.消息转换器"></a>3.7.消息转换器</h2><p>之前说过，Spring会把你发送的消息序列化为字节发送给MQ，接收消息的时候，还会把字节反序列化为Java对象。</p><p>只不过，默认情况下Spring采用的序列化方式是JDK序列化。众所周知，JDK序列化存在下列问题：</p><ul><li>数据体积过大</li><li>有安全漏洞</li><li>可读性差</li></ul><p>我们来测试一下。</p><h3 id="3-7-1-测试默认转换器"><a href="#3-7-1-测试默认转换器" class="headerlink" title="3.7.1.测试默认转换器"></a>3.7.1.测试默认转换器</h3><p>我们修改消息发送的代码，发送一个Map对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSendMap</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-comment">// 准备消息</span><br>    Map&lt;String,Object&gt; msg = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    msg.put(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;Jack&quot;</span>);<br>    msg.put(<span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-number">21</span>);<br>    <span class="hljs-comment">// 发送消息</span><br>    rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;simple.queue&quot;</span>,<span class="hljs-string">&quot;&quot;</span>, msg);<br>&#125;<br></code></pre></td></tr></table></figure><p>停止consumer服务</p><p>发送消息后查看控制台：</p><h3 id="3-7-2-配置JSON转换器"><a href="#3-7-2-配置JSON转换器" class="headerlink" title="3.7.2.配置JSON转换器"></a>3.7.2.配置JSON转换器</h3><p>显然，JDK序列化方式并不合适。我们希望消息体的体积更小、可读性更高，因此可以使用JSON方式来做序列化和反序列化。</p><p>在publisher和consumer两个服务中都引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.dataformat<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-dataformat-xml<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.10<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>配置消息转换器。</p><p>在启动类中添加一个Bean即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> MessageConverter <span class="hljs-title function_">jsonMessageConverter</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jackson2JsonMessageConverter</span>();<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>RabbitMQ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>RabbitMQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RedisTemplate的List类型详解</title>
    <link href="/article/361d3ff9/"/>
    <url>/article/361d3ff9/</url>
    
    <content type="html"><![CDATA[<h1 id="RedisTemplate的List类型详解"><a href="#RedisTemplate的List类型详解" class="headerlink" title="RedisTemplate的List类型详解"></a>RedisTemplate的List类型详解</h1><h2 id="List类型"><a href="#List类型" class="headerlink" title="List类型"></a>List类型</h2><p>  Redis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。</p><h4 id="索引查询"><a href="#索引查询" class="headerlink" title="索引查询"></a>索引查询</h4><p>  通过索引获取列表中的元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">redisTemplate.opsForList().index(key, index)<br></code></pre></td></tr></table></figure><h4 id="范围查询"><a href="#范围查询" class="headerlink" title="范围查询"></a>范围查询</h4><p>  获取列表指定范围内的元素(start开始位置, 0是开始位置，end 结束位置, -1返回所有)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">redisTemplate.<span class="hljs-title function_">opsForList</span>().<span class="hljs-title function_">range</span>(key, start, end)<br></code></pre></td></tr></table></figure><h4 id="放在最前面"><a href="#放在最前面" class="headerlink" title="放在最前面"></a>放在最前面</h4><p>  存储在list的头部，添加一个就把它放在最前面的索引处</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">redisTemplate.<span class="hljs-title function_">opsForList</span>().<span class="hljs-title function_">leftPush</span>(key, value)<br></code></pre></td></tr></table></figure><h4 id="多值插入"><a href="#多值插入" class="headerlink" title="多值插入"></a>多值插入</h4><p>  把多个值存入List中(value可以是多个值，也可以是一个Collection value)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">redisTemplate.<span class="hljs-title function_">opsForList</span>().<span class="hljs-title function_">leftPushAll</span>(key, value)<br></code></pre></td></tr></table></figure><h4 id="存在插入"><a href="#存在插入" class="headerlink" title="存在插入"></a>存在插入</h4><p>  List存在的时候再加入</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">redisTemplate.<span class="hljs-title function_">opsForList</span>().<span class="hljs-title function_">leftPushIfPresent</span>(key, value)<br></code></pre></td></tr></table></figure><h4 id="指定值前插入"><a href="#指定值前插入" class="headerlink" title="指定值前插入"></a>指定值前插入</h4><p>  如果pivot处值存在则在pivot前面添加</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">redisTemplate.<span class="hljs-title function_">opsForList</span>().<span class="hljs-title function_">leftPush</span>(key, pivot, value)<br></code></pre></td></tr></table></figure><h4 id="先进先出添加"><a href="#先进先出添加" class="headerlink" title="先进先出添加"></a>先进先出添加</h4><p>  按照先进先出的顺序来添加(value可以是多个值，或者是Collection var2)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">redisTemplate.<span class="hljs-title function_">opsForList</span>().<span class="hljs-title function_">rightPush</span>(key, value) redisTemplate.<span class="hljs-title function_">opsForList</span>().<span class="hljs-title function_">rightPushAll</span>(key, value)<br></code></pre></td></tr></table></figure><h4 id="在指定值后插入"><a href="#在指定值后插入" class="headerlink" title="在指定值后插入"></a>在指定值后插入</h4><p>  在pivot元素的右边添加值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">redisTemplate.<span class="hljs-title function_">opsForList</span>().<span class="hljs-title function_">rightPush</span>(key, pivot, value)<br></code></pre></td></tr></table></figure><h4 id="指定索引值"><a href="#指定索引值" class="headerlink" title="指定索引值"></a>指定索引值</h4><p>  设置指定索引处元素的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">redisTemplate.<span class="hljs-title function_">opsForList</span>().<span class="hljs-title function_">set</span>(key, index, value)<br></code></pre></td></tr></table></figure><h4 id="移除并获取列表中第一个元素"><a href="#移除并获取列表中第一个元素" class="headerlink" title="移除并获取列表中第一个元素"></a>移除并获取列表中第一个元素</h4><p>  移除并获取列表中第一个元素(如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">redisTemplate.<span class="hljs-title function_">opsForList</span>().<span class="hljs-title function_">leftPop</span>(key) redisTemplate.<span class="hljs-title function_">opsForList</span>().<span class="hljs-title function_">leftPop</span>(key, timeout, unit)<br></code></pre></td></tr></table></figure><h4 id="移除并获取列表最后一个元素"><a href="#移除并获取列表最后一个元素" class="headerlink" title="移除并获取列表最后一个元素"></a>移除并获取列表最后一个元素</h4><p>  移除并获取列表最后一个元素</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">redisTemplate.<span class="hljs-title function_">opsForList</span>().<span class="hljs-title function_">rightPop</span>(key) redisTemplate.<span class="hljs-title function_">opsForList</span>().<span class="hljs-title function_">rightPop</span>(key, timeout, unit)<br></code></pre></td></tr></table></figure><h4 id="将值放入第一个"><a href="#将值放入第一个" class="headerlink" title="将值放入第一个"></a>将值放入第一个</h4><p>   从一个队列的右边弹出一个元素并将这个元素放入另一个指定队列的最左边</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">redisTemplate.<span class="hljs-title function_">opsForList</span>().<span class="hljs-title function_">rightPopAndLeftPush</span>(sourceKey, destinationKey) redisTemplate.<span class="hljs-title function_">opsForList</span>().<span class="hljs-title function_">rightPopAndLeftPush</span>(sourceKey, destinationKey, timeout, unit)<br></code></pre></td></tr></table></figure><h4 id="删除集合中值等于value的元素"><a href="#删除集合中值等于value的元素" class="headerlink" title="删除集合中值等于value的元素"></a>删除集合中值等于value的元素</h4><p>  删除集合中值等于value的元素(index&#x3D;0, 删除所有值等于value的元素; index&gt;0, 从头部开始删除第一个值等于value的元素; index&lt;0, 从尾部开始删除第一个值等于value的元素)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">redisTemplate.<span class="hljs-title function_">opsForList</span>().<span class="hljs-title function_">remove</span>(key, index, value)<br></code></pre></td></tr></table></figure><h4 id="将List列表进行剪裁"><a href="#将List列表进行剪裁" class="headerlink" title="将List列表进行剪裁"></a>将List列表进行剪裁</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">redisTemplate.<span class="hljs-title function_">opsForList</span>().<span class="hljs-title function_">trim</span>(key, start, end)<br></code></pre></td></tr></table></figure><h4 id="获取当前key的List列表长度"><a href="#获取当前key的List列表长度" class="headerlink" title="获取当前key的List列表长度"></a>获取当前key的List列表长度</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">redisTemplate.<span class="hljs-title function_">opsForList</span>().<span class="hljs-title function_">size</span>(key)<br></code></pre></td></tr></table></figure><h2 id="Set类型"><a href="#Set类型" class="headerlink" title="Set类型"></a>Set类型</h2><p>  Redis 的 Set 是 String 类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。集合对象的编码可以是 intset 或者 hashtable。Redis 中集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。</p><h4 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">redisTemplate.<span class="hljs-title function_">opsForSet</span>().<span class="hljs-title function_">add</span>(key, values)<br></code></pre></td></tr></table></figure><h4 id="移除元素-单个值、多个值"><a href="#移除元素-单个值、多个值" class="headerlink" title="移除元素(单个值、多个值)"></a>移除元素(单个值、多个值)</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">redisTemplate.<span class="hljs-title function_">opsForSet</span>().<span class="hljs-title function_">remove</span>(key, values)<br></code></pre></td></tr></table></figure><h4 id="删除并且返回一个随机的元素"><a href="#删除并且返回一个随机的元素" class="headerlink" title="删除并且返回一个随机的元素"></a>删除并且返回一个随机的元素</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">redisTemplate.<span class="hljs-title function_">opsForSet</span>().<span class="hljs-title function_">pop</span>(key)<br></code></pre></td></tr></table></figure><h4 id="获取集合的大小"><a href="#获取集合的大小" class="headerlink" title="获取集合的大小"></a>获取集合的大小</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">redisTemplate.<span class="hljs-title function_">opsForSet</span>().<span class="hljs-title function_">size</span>(key)<br></code></pre></td></tr></table></figure><h4 id="判断集合是否包含value"><a href="#判断集合是否包含value" class="headerlink" title="判断集合是否包含value"></a>判断集合是否包含value</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">redisTemplate.<span class="hljs-title function_">opsForSet</span>().<span class="hljs-title function_">isMember</span>(key, value)<br></code></pre></td></tr></table></figure><h4 id="获取两个集合的交集-key对应的无序集合与otherKey对应的无序集合求交集"><a href="#获取两个集合的交集-key对应的无序集合与otherKey对应的无序集合求交集" class="headerlink" title="获取两个集合的交集(key对应的无序集合与otherKey对应的无序集合求交集)"></a>获取两个集合的交集(key对应的无序集合与otherKey对应的无序集合求交集)</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">redisTemplate.<span class="hljs-title function_">opsForSet</span>().<span class="hljs-title function_">intersect</span>(key, otherKey)<br></code></pre></td></tr></table></figure><h4 id="获取多个集合的交集-Collection-var2"><a href="#获取多个集合的交集-Collection-var2" class="headerlink" title="获取多个集合的交集(Collection var2)"></a>获取多个集合的交集(Collection var2)</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">redisTemplate.<span class="hljs-title function_">opsForSet</span>().<span class="hljs-title function_">intersect</span>(key, otherKeys)<br></code></pre></td></tr></table></figure><h4 id="key集合与otherKey集合的交集存储到destKey集合中-其中otherKey可以为单个值或者集合"><a href="#key集合与otherKey集合的交集存储到destKey集合中-其中otherKey可以为单个值或者集合" class="headerlink" title="key集合与otherKey集合的交集存储到destKey集合中(其中otherKey可以为单个值或者集合)"></a>key集合与otherKey集合的交集存储到destKey集合中(其中otherKey可以为单个值或者集合)</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">redisTemplate.<span class="hljs-title function_">opsForSet</span>().<span class="hljs-title function_">intersectAndStore</span>(key, otherKey, destKey)<br></code></pre></td></tr></table></figure><h4 id="key集合与多个集合的交集存储到destKey无序集合中"><a href="#key集合与多个集合的交集存储到destKey无序集合中" class="headerlink" title="key集合与多个集合的交集存储到destKey无序集合中"></a>key集合与多个集合的交集存储到destKey无序集合中</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">redisTemplate.<span class="hljs-title function_">opsForSet</span>().<span class="hljs-title function_">intersectAndStore</span>(key, otherKeys, destKey)<br></code></pre></td></tr></table></figure><h4 id="获取两个或者多个集合的并集-otherKeys可以为单个值或者是集合"><a href="#获取两个或者多个集合的并集-otherKeys可以为单个值或者是集合" class="headerlink" title="获取两个或者多个集合的并集(otherKeys可以为单个值或者是集合)"></a>获取两个或者多个集合的并集(otherKeys可以为单个值或者是集合)</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">redisTemplate.<span class="hljs-title function_">opsForSet</span>().<span class="hljs-title function_">union</span>(key, otherKeys)<br></code></pre></td></tr></table></figure><h4 id="key集合与otherKey集合的并集存储到destKey中-otherKeys可以为单个值或者是集合"><a href="#key集合与otherKey集合的并集存储到destKey中-otherKeys可以为单个值或者是集合" class="headerlink" title="key集合与otherKey集合的并集存储到destKey中(otherKeys可以为单个值或者是集合)"></a>key集合与otherKey集合的并集存储到destKey中(otherKeys可以为单个值或者是集合)</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">redisTemplate.<span class="hljs-title function_">opsForSet</span>().<span class="hljs-title function_">unionAndStore</span>(key, otherKey, destKey)<br></code></pre></td></tr></table></figure><h4 id="获取两个或者多个集合的差集-otherKeys可以为单个值或者是集合"><a href="#获取两个或者多个集合的差集-otherKeys可以为单个值或者是集合" class="headerlink" title="获取两个或者多个集合的差集(otherKeys可以为单个值或者是集合)"></a>获取两个或者多个集合的差集(otherKeys可以为单个值或者是集合)</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">redisTemplate.<span class="hljs-title function_">opsForSet</span>().<span class="hljs-title function_">difference</span>(key, otherKeys)<br></code></pre></td></tr></table></figure><h4 id="差集存储到destKey中-otherKeys可以为单个值或者集合"><a href="#差集存储到destKey中-otherKeys可以为单个值或者集合" class="headerlink" title="差集存储到destKey中(otherKeys可以为单个值或者集合)"></a>差集存储到destKey中(otherKeys可以为单个值或者集合)</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">redisTemplate.<span class="hljs-title function_">opsForSet</span>().<span class="hljs-title function_">differenceAndStore</span>(key, otherKey, destKey)<br></code></pre></td></tr></table></figure><h4 id="随机获取集合中的一个元素"><a href="#随机获取集合中的一个元素" class="headerlink" title="随机获取集合中的一个元素"></a>随机获取集合中的一个元素</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">redisTemplate.<span class="hljs-title function_">opsForSet</span>().<span class="hljs-title function_">randomMember</span>(key)<br></code></pre></td></tr></table></figure><h4 id="获取集合中的所有元素"><a href="#获取集合中的所有元素" class="headerlink" title="获取集合中的所有元素"></a>获取集合中的所有元素</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">redisTemplate.<span class="hljs-title function_">opsForSet</span>().<span class="hljs-title function_">members</span>(key)<br></code></pre></td></tr></table></figure><h4 id="随机获取集合中count个元素"><a href="#随机获取集合中count个元素" class="headerlink" title="随机获取集合中count个元素"></a>随机获取集合中count个元素</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">redisTemplate.<span class="hljs-title function_">opsForSet</span>().<span class="hljs-title function_">randomMembers</span>(key, count)<br></code></pre></td></tr></table></figure><h4 id="获取多个key无序集合中的元素（去重），count表示个数"><a href="#获取多个key无序集合中的元素（去重），count表示个数" class="headerlink" title="获取多个key无序集合中的元素（去重），count表示个数"></a>获取多个key无序集合中的元素（去重），count表示个数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">redisTemplate.<span class="hljs-title function_">opsForSet</span>().<span class="hljs-title function_">distinctRandomMembers</span>(key, count)<br></code></pre></td></tr></table></figure><h4 id="遍历set类似于Interator-ScanOptions-NONE为显示所有的"><a href="#遍历set类似于Interator-ScanOptions-NONE为显示所有的" class="headerlink" title="遍历set类似于Interator(ScanOptions.NONE为显示所有的)"></a>遍历set类似于Interator(ScanOptions.NONE为显示所有的)</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">redisTemplate.<span class="hljs-title function_">opsForSet</span>().<span class="hljs-title function_">scan</span>(key, options)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RedisTemplate</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux常用命令(Java)</title>
    <link href="/article/72ff45fc/"/>
    <url>/article/72ff45fc/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux常用命令-Java"><a href="#Linux常用命令-Java" class="headerlink" title="Linux常用命令(Java)"></a>Linux常用命令(Java)</h1><h2 id="一-ls命令："><a href="#一-ls命令：" class="headerlink" title="一.ls命令："></a>一.ls命令：</h2><ul><li><p>ls &#x2F;：查看根目录</p></li><li><p>ls -l: 显示详细信息</p></li><li><p>ls -a:显示隐藏文件</p></li></ul><h2 id="二-目录切换："><a href="#二-目录切换：" class="headerlink" title="二.目录切换："></a>二.目录切换：</h2><ul><li><p>pwd ：查看当前所在目录</p></li><li><p>cd ：切换目录</p></li><li><p>cd ..  ：退回到上一级目录</p></li><li><p>cd &#x2F;  ：切换到根目录</p></li></ul><h2 id="三-创建文件夹："><a href="#三-创建文件夹：" class="headerlink" title="三.创建文件夹："></a>三.创建文件夹：</h2><ul><li><p>mkdir  aaa 相对路径写法</p></li><li><p>mkdir  &#x2F;bbb 绝对路径写法</p></li><li><p>mkdir -p aaa&#x2F;bbb&#x2F;ccc 级联创建目录</p></li><li><p>rm：删除目录 rm -r：</p></li><li><p>递归删除 rm -rf：递归删除，不提示</p></li><li><p>touch：创建空文件</p></li></ul><h2 id="四-查看："><a href="#四-查看：" class="headerlink" title="四.查看："></a>四.查看：</h2><ul><li><p>echo   ：输出</p></li><li><p>cat  ：    由第一行开始显示内容，并将所有内容输出</p></li><li><p>tac     从最后一行倒序显示内容，并将所有内容输出</p></li><li><p>head    只显示头几行</p></li><li><p>tail    只显示最后几行</p></li><li><p>tailf   类似于tail -f</p></li></ul><blockquote><p>   ：重定向，把一个命令的执行结果，重定向到一个文件中去，屏幕上不会再显示结果</p></blockquote><p>   例如：</p><blockquote><p>ls &gt; aaa.txt   重定向，把ls的结果作为字符串写入、覆盖到aaa.txt文件中      </p><p> ls &gt;&gt; aaa.txt   重定向，把ls的结果作为字符串追加到aaa.txt文件中</p></blockquote><h2 id="五-编辑："><a href="#五-编辑：" class="headerlink" title="五.编辑："></a>五.编辑：</h2><ul><li><p>vi：编辑文件    （如果没有就会创建文件）</p></li><li><p>-i：编辑模式   （先按下i,再去改写）</p></li><li><p>保存：先按Esc(先退出编辑状态) ，再输入英文的冒号 :（先按shift,再按：）wq</p></li><li><p>:wq 保存编辑的文件，其中 -w：保存    -q：</p></li><li><p>:q! 为不保存文件</p></li><li><p>快捷键：（非编辑模式下）</p></li><li><p>yy：复制整行   p：粘贴（yy和p不能在编辑模式下）</p></li><li><p>G：直接跳到文件的末行  ， gg：直接跳到文件首行</p></li><li><p>&#x2F;:搜索内容，n匹配下一个按tab补全</p></li><li><p>dd：删除一行</p></li></ul><h2 id="六-拷贝-移动，查找："><a href="#六-拷贝-移动，查找：" class="headerlink" title="六.拷贝,移动，查找："></a>六.拷贝,移动，查找：</h2><ul><li>cp：拷贝    cp a.txt b.txt</li><li>mv：移动&#x2F;改名   mv a.txt    aa.txt 修改名字   把a修改成aa</li></ul><p>如果你想在当前目录下 查找”hello,world!”字符串,可以这样:</p><p><code>grep -rn &quot;hello,world!&quot; *</code></p><ul><li>: 表示当前目录所有文件，也可以是某个文件名</li></ul><ul><li><p>-r 是递归查找</p></li><li><p>-n 是显示行号</p></li><li><p>-R 查找所有文件包含子目录</p></li><li><p>-i 忽略大小写</p></li></ul><h2 id="七-解压"><a href="#七-解压" class="headerlink" title="七.解压"></a>七.解压</h2><ul><li>解压到当前目录 tar -zxvf jdk-8u181-linux-x64.tar.gz  表示解压成：&#x2F;&#x2F;解压tar.gz</li><li>解压到指定目录 tar -zxvf jdk-8u181-linux-x64.tar.gz -C &#x2F;usr&#x2F;local&#x2F;</li></ul><p>  -z：有gzip属性的<br>  -x：解压</p><ul><li><p>-v：显示所有过程</p></li><li><p>-f: 使用档案名字，切记，这个参数是最后一个参数，后面只能接档案名。</p></li><li><p>-t：查看内容</p></li><li><p>-c: 建立压缩档案<br>-r：向压缩归档文件末尾追加文件<br>-u：更新原压缩包中的文件</p></li><li><p>tar -czf jpg.tar.gz *.jpg &#x2F;&#x2F;将目录里所有jpg文件打包成jpg.tar后，并且将其用gzip压缩，生成一个gzip压缩过的包，命名为jpg.tar.gz</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux命令</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>windows系统如何查看端口被占用、杀进程</title>
    <link href="/article/e0921f05/"/>
    <url>/article/e0921f05/</url>
    
    <content type="html"><![CDATA[<h1 id="windows系统如何查看端口被占用、杀进程"><a href="#windows系统如何查看端口被占用、杀进程" class="headerlink" title="windows系统如何查看端口被占用、杀进程"></a>windows系统如何查看端口被占用、杀进程</h1><ol><li>首先是启动windows的命令窗口，按键盘上的<code>windows+R</code>，然后在输入框中输入<code>cmd</code>，既可以启动命令窗口。</li><li>进入windows命令窗口之后，输入命令，输入<code>netstat -ano</code>然后回车，就可以看到系统当前所有的端口使用情况。</li><li>通过命令查找某一特定端口，在命令窗口中输入命令中输入<code>netstat -ano |findstr &quot;端口号&quot;</code>，然后回车就可以看到这个端口被哪个应用占用。</li><li>查看到对应的进程id之后，就可以通过id查找对应的进程名称，使用命令<code>tasklist |findstr &quot;进程id号&quot;</code>。</li><li>通过命令杀掉进程，或者是直接根据进程的名称杀掉所有的进程，，在命令框中输入如下命令<code>taskkill /f /t /im &quot;进程id或者进程名称&quot;</code>。</li><li>杀掉对应的进程id或者是进程名称之后，然后再通过查找命令，查找对应的端口，现在就可以看到这个端口没有被其他应用所占用。</li></ol>]]></content>
    
    
    <categories>
      
      <category>windows命令</category>
      
    </categories>
    
    
    <tags>
      
      <tag>windows</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot获取Request对象的几种方式</title>
    <link href="/article/509fe048/"/>
    <url>/article/509fe048/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot获取Request对象的几种方式"><a href="#SpringBoot获取Request对象的几种方式" class="headerlink" title="SpringBoot获取Request对象的几种方式"></a>SpringBoot获取Request对象的几种方式</h1><p>HttpServletRequest 简称 Request，它是一个 Servlet API 提供的对象，用于获取客户端发起的 HTTP 请求信息。例如：获取请求参数、获取请求头、获取 Session 会话信息、获取请求的 IP 地址等信息。</p><p>那么问题来了，在 Spring Boot 中，获取 Request 对象的方法有哪些？</p><p>常见的获取 Request 对象的方法有以下三种：</p><ol><li>通过请求参数中获取 Request 对象；</li><li>通过 RequestContextHolder 获取 Request 对象；</li><li>通过自动注入获取 Request 对象。</li></ol><p>具体实现如下。</p><h2 id="1-通过请求参数获取"><a href="#1-通过请求参数获取" class="headerlink" title="1.通过请求参数获取"></a>1.通过请求参数获取</h2><p>实现代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">java复制代码<span class="hljs-meta">@RequestMapping(&quot;/index&quot;)</span><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">index</span><span class="hljs-params">(HttpServletRequest request)</span>&#123;<br>　　<span class="hljs-comment">// do something</span><br>&#125;<br></code></pre></td></tr></table></figure><p>该方法实现的原理是 Controller 开始处理请求时，Spring 会将 Request 对象赋值到方法参数中，我们直接设置到参数中即可得到 Request 对象。</p><h2 id="2-通过-RequestContextHolder-获取"><a href="#2-通过-RequestContextHolder-获取" class="headerlink" title="2.通过 RequestContextHolder 获取"></a>2.通过 RequestContextHolder 获取</h2><p>在 Spring Boot 中，RequestContextHolder 是 Spring 框架提供的一个工具类，用于在多线程环境中存储和访问与当前线程相关的请求上下文信息。它主要用于将当前请求的信息存储在线程范围内，以便在不同的组件中共享和访问这些信息，特别是在没有直接传递参数的情况下。 RequestContextHolder 的主要作用有以下几个：</p><ol><li><strong>访问请求上下文信息</strong>： 在 Web 应用中，每个请求都会触发一个新的线程来处理。RequestContextHolder 允许你在任何地方获取当前请求的上下文信息，比如 HttpServletRequest 对象、会话信息等。</li><li><strong>跨层传递信息</strong>： 在多层架构中，比如控制器、服务层、数据访问层，你可能需要在这些层之间传递一些与请求相关的信息，但不想在每个方法中显式传递。通过 RequestContextHolder，你可以在一处设置请求信息，在其他地方获取并使用。</li><li><strong>线程安全的上下文共享</strong>： RequestContextHolder 使用线程局部变量来存储请求上下文信息，确保在多线程环境下每个线程访问的上下文信息都是独立的，避免了线程安全问题。</li></ol><p>因此我们可以使用 RequestContextHolde 获取 Request 对象，实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">java复制代码<span class="hljs-meta">@RequestMapping(&quot;/index&quot;)</span><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">index</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-type">ServletRequestAttributes</span> <span class="hljs-variable">servletRequestAttributes</span> <span class="hljs-operator">=</span> (ServletRequestAttributes)RequestContextHolder.getRequestAttributes();<br><span class="hljs-type">HttpServletRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> servletRequestAttributes.getRequest();<br><span class="hljs-comment">// do something</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-通过自动注入获取"><a href="#3-通过自动注入获取" class="headerlink" title="3.通过自动注入获取"></a>3.通过自动注入获取</h2><p>HttpServletRequest 对象也可以通过自动注入，如属性注入的方式获取，如下代码所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">java复制代码<span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HomeController</span>&#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> HttpServletRequest request; <span class="hljs-comment">// 自动注入 request 对象</span><br>    <span class="hljs-comment">// do something</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Request 对象是获取客户端 HTTP 请求的重要对象，也是 Spring Boot 的重要对象之一，获取此对象的常用方法有：通过请求参数获取、通过 RequestContextHolder 获取，以及通过注入获取。</p>]]></content>
    
    
    <categories>
      
      <category>SpringBoot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>用户中心直播笔记</title>
    <link href="/article/6db70910/"/>
    <url>/article/6db70910/</url>
    
    <content type="html"><![CDATA[<h1 id="用户中心项目笔记"><a href="#用户中心项目笔记" class="headerlink" title="用户中心项目笔记"></a>用户中心项目笔记</h1><h3 id="项目源码"><a href="#项目源码" class="headerlink" title="项目源码"></a>项目源码</h3><p>用户中心前端项目源码：<a href="http://gitlab.code-nav.cn/root/user-center-frontend">http://gitlab.code-nav.cn/root/user-center-frontend</a></p><p>用户中心后端项目源码：<a href="http://gitlab.code-nav.cn/root/user-center-backend">http://gitlab.code-nav.cn/root/user-center-backend</a></p><h2 id="企业做项目流程"><a href="#企业做项目流程" class="headerlink" title="企业做项目流程"></a>企业做项目流程</h2><p>需求分析 &#x3D;&gt; 设计（概要设计、详细设计）&#x3D;&gt; 技术选型 &#x3D;&gt; 初始化 &#x2F; 引入需要的技术 &#x3D;&gt; 写 Demo &#x3D;&gt; 写代码（实现业务逻辑） &#x3D;&gt; 测试（单元测试、系统测试）&#x3D;&gt; 代码提交 &#x2F; 代码评审 &#x3D;&gt; 部署 &#x3D;&gt; 发布上线</p><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><ol><li>登录 &#x2F; 注册</li><li>用户管理（仅管理员可见）对用户的查询或者修改</li><li>用户校验（仅星球用户可见）</li></ol><h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><p>前端：三件套 + React + 组件库 Ant Design + Umi + Ant Design Pro（现成的管理系统）</p><p>后端：</p><ul><li>java</li><li>spring（依赖注入框架，帮助你管理 Java 对象，集成一些其他的内容）</li><li>springmvc（web 框架，提供接口访问、restful接口等能力）</li><li>mybatis（Java 操作数据库的框架，持久层框架，对 jdbc 的封装）</li><li>mybatis-plus（对 mybatis 的增强，不用写 sql 也能实现增删改查）</li><li>springboot（<strong>快速启动</strong> &#x2F; 快速集成项目。不用自己管理 spring 配置，不用自己整合各种框架）</li><li>junit 单元测试库</li><li>mysql 数据库</li></ul><p>部署：服务器 &#x2F; 容器（平台）</p><h2 id="3-种初始化-Java-项目的方式"><a href="#3-种初始化-Java-项目的方式" class="headerlink" title="3 种初始化 Java 项目的方式"></a>3 种初始化 Java 项目的方式</h2><ol><li>GitHub 搜现成的代码</li><li>SpringBoot 官方的模板生成器（<a href="https://start.spring.io/%EF%BC%89">https://start.spring.io/）</a></li><li>直接在 IDEA 开发工具中生成  ✔</li></ol><p>如果要引入 java 的包，可以去 maven 中心仓库寻找（<a href="http://mvnrepository.com/%EF%BC%89">http://mvnrepository.com/）</a></p><h2 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h2><p>什么是数据库？存数据的</p><p>数据库里有什么？数据表（理解为 excel 表格）</p><p>java 操作数据库？程序代替人工</p><h3 id="什么是设计数据库表？"><a href="#什么是设计数据库表？" class="headerlink" title="什么是设计数据库表？"></a>什么是设计数据库表？</h3><p>有哪些表（模型）？表中有哪些字段？字段的类型？数据库字段添加索引？表与表之间的关联？</p><p>举例：性别是否需要加索引？</p><h3 id="用户表设计"><a href="#用户表设计" class="headerlink" title="用户表设计"></a>用户表设计</h3><p>id（主键）bigint</p><p>username 昵称  varchar</p><p>userAccount 登录账号 </p><p>avatarUrl 头像 varchar</p><p>gender 性别 tinyint</p><p>userPassword 密码  varchar</p><p>phone 电话 varchar</p><p>email 邮箱 varchar</p><p>userStatus 用户状态 int  0 - 正常 </p><p>createTime 创建时间（数据插入时间）datetime</p><p>updateTime 更新时间（数据更新时间）datetime</p><p>isDelete 是否删除 0 1（逻辑删除）tinyint</p><p>userRole 用户角色 0 - 普通用户 1 - 管理员</p><h3 id="自动生成器的使用"><a href="#自动生成器的使用" class="headerlink" title="自动生成器的使用"></a>自动生成器的使用</h3><p>MyBatisX 插件，自动根据数据库生成：</p><ul><li>domain：实体对象</li><li>mapper：操作数据库的对象</li><li>mapper.xml：定义了 mapper 对象和数据库的关联，可以在里面自己写 SQL</li><li>service：包含常用的增删改查</li><li>serviceImpl：具体实现 service</li></ul><p>从而提高开发效率！</p><h2 id="注册逻辑设计"><a href="#注册逻辑设计" class="headerlink" title="注册逻辑设计"></a>注册逻辑设计</h2><ol><li>用户在前端输入账户和密码、以及校验码（todo）</li><li>校验用户的账户、密码、校验密码，是否符合要求<ol><li>非空</li><li>账户长度 <strong>不小于</strong> 4 位</li><li>密码就 <strong>不小于</strong> 8 位吧</li><li>账户不能重复</li><li>账户不包含特殊字符</li><li>密码和校验密码相同</li></ol></li><li>对密码进行加密（密码千万不要直接以明文存储到数据库中）</li><li>向数据库插入用户数据</li></ol><h2 id="登录功能"><a href="#登录功能" class="headerlink" title="登录功能"></a>登录功能</h2><h3 id="接口设计"><a href="#接口设计" class="headerlink" title="接口设计"></a>接口设计</h3><p>接受参数：用户账户、密码</p><p>请求类型：POST </p><p>请求体：JSON 格式的数据</p><blockquote><p>请求参数很长时不建议用 get</p></blockquote><p>返回值：用户信息（ <strong>脱敏</strong> ）</p><h3 id="登录逻辑"><a href="#登录逻辑" class="headerlink" title="登录逻辑"></a>登录逻辑</h3><ol><li><p>校验用户账户和密码是否合法</p><ol><li>非空</li><li>账户长度不小于 4 位</li><li>密码就不小于 8 位</li><li>账户不包含特殊字符</li></ol></li><li><p>校验密码是否输入正确，要和数据库中的密文密码去对比</p></li><li><p>用户信息脱敏，隐藏敏感信息，防止数据库中的字段泄露</p></li><li><p>我们要记录用户的登录态（session），将其存到服务器上（用后端 SpringBoot 框架封装的服务器 tomcat 去记录）</p><p>cookie</p></li><li><p>返回脱敏后的用户信息</p></li></ol><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>控制层 Controller 封装请求</p><p>application.yml 指定接口全局路径前缀：</p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">servlet</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-attribute">context-path</span><span class="hljs-punctuation">:</span> <span class="hljs-string">/api</span><br></code></pre></td></tr></table></figure><p>控制器注解：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@RestController</span> 适用于编写 restful 风格的 api，返回值默认为 json 类型<br></code></pre></td></tr></table></figure><p>校验写在哪里？</p><ul><li>controller 层倾向于对请求参数本身的校验，不涉及业务逻辑本身（越少越好）</li><li>service 层是对业务逻辑的校验（有可能被 controller 之外的类调用）</li></ul><h3 id="如何知道是哪个用户登录了？"><a href="#如何知道是哪个用户登录了？" class="headerlink" title="如何知道是哪个用户登录了？"></a>如何知道是哪个用户登录了？</h3><blockquote><p>javaweb 这一块的知识</p></blockquote><ol><li><p>连接服务器端后，得到一个 session 状态（匿名会话），返回给前端</p></li><li><p>登录成功后，得到了登录成功的 session，并且给该sessio n设置一些值（比如用户信息），返回给前端一个设置 cookie 的 ”命令“ </p><p><strong>session &#x3D;&gt; cookie</strong> </p></li><li><p>前端接收到后端的命令后，设置 cookie，保存到浏览器内</p></li><li><p>前端再次请求后端的时候（相同的域名），在请求头中带上cookie去请求</p></li><li><p>后端拿到前端传来的 cookie，找到对应的 session</p></li><li><p>后端从 session 中可以取出基于该 session 存储的变量（用户的登录信息、登录名）</p></li></ol><h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><p>接口设计关键：必须鉴权！！！</p><ol><li>查询用户（允许根据用户名查询）</li><li>删除用户</li></ol><h2 id="写代码流程"><a href="#写代码流程" class="headerlink" title="写代码流程"></a>写代码流程</h2><ol><li>先做设计</li><li>代码实现</li><li>持续优化！！！（复用代码、提取公共逻辑 &#x2F; 常量）</li></ol><h2 id="前后端交互"><a href="#前后端交互" class="headerlink" title="前后端交互"></a>前后端交互</h2><p>前端需要向后端发送请求才能获取数据 &#x2F; 执行操作。</p><p>怎么发请求：前端使用 ajax 来请求后端</p><h3 id="前端请求库及封装关系"><a href="#前端请求库及封装关系" class="headerlink" title="前端请求库及封装关系"></a>前端请求库及封装关系</h3><ul><li><p>axios 封装了 ajax</p></li><li><p>request 是 ant design 项目又封装了一次</p></li></ul><p>追踪 request 源码：用到了 umi 的插件、requestConfig 配置文件</p><h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><p>正向代理：替客户端向服务器发送请求，可以解决跨域问题</p><p>反向代理：替服务器统一接收请求。</p><p>怎么实现代理？</p><ul><li>Nginx 服务器</li><li>Node.js 服务器</li></ul><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>原本请求：<a href="http://localhost:8000/api/user/login">http://localhost:8000/api/user/login</a></p><p>代理到请求：<a href="http://localhost:8080/api/user/login">http://localhost:8080/api/user/login</a></p><p><img src="https://qiniuyun.code-nav.cn/img/image-20220319005859098.png"></p><h2 id="前端框架介绍"><a href="#前端框架介绍" class="headerlink" title="前端框架介绍"></a>前端框架介绍</h2><h3 id="Ant-Design-Pro（Umi-框架）权限管理"><a href="#Ant-Design-Pro（Umi-框架）权限管理" class="headerlink" title="Ant Design Pro（Umi 框架）权限管理"></a>Ant Design Pro（Umi 框架）权限管理</h3><ul><li>app.tsx：项目全局入口文件，定义了整个项目中使用的公共数据（比如用户信息）</li><li>access.ts 控制用户的访问权限</li></ul><p>获取初始状态流程：首次访问页面（刷新页面），进入 app.tsx，执行 getInitialState 方法，该方法的返回值就是全局可用的状态值。</p><h3 id="ProComponents-高级表单"><a href="#ProComponents-高级表单" class="headerlink" title="ProComponents 高级表单"></a>ProComponents 高级表单</h3><ol><li>通过 columns 定义表格有哪些列</li><li>columns 属性<ul><li>dataIndex 对应返回数据对象的属性</li><li>title 表格列名</li><li>copyable 是否允许复制</li><li>ellipsis 是否允许缩略</li><li>valueType：用于声明这一列的类型（dateTime、select）</li></ul></li></ol><h3 id="框架关系"><a href="#框架关系" class="headerlink" title="框架关系"></a>框架关系</h3><p>Ant Design 组件库 &#x3D;&gt; 基于 React 实现</p><p>Ant Design Procomponents &#x3D;&gt; 基于 Ant Design 实现</p><p>Ant Design Pro 后台管理系统 &#x3D;&gt; 基于 Ant Design + React + Ant Design Procomponents + 其他的库实现</p><h3 id="其他知识"><a href="#其他知识" class="headerlink" title="其他知识"></a>其他知识</h3><p>MFSU：前端编译优化</p><h2 id="后端优化"><a href="#后端优化" class="headerlink" title="后端优化"></a>后端优化</h2><h3 id="通用返回对象"><a href="#通用返回对象" class="headerlink" title="通用返回对象"></a>通用返回对象</h3><p>目的：给对象补充一些信息，告诉前端这个请求在业务层面上是成功还是失败</p><p>200、404、500、502、503</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;yupi&quot;</span><br><span class="hljs-punctuation">&#125;</span><br><br>↓<br><br><span class="hljs-comment">// 成功</span><br><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;code&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span> <span class="hljs-comment">// 业务状态码</span><br>    <span class="hljs-attr">&quot;data&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;yupi&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;message&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ok&quot;</span><br><span class="hljs-punctuation">&#125;</span><br><br><br><span class="hljs-comment">// 错误</span><br><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;code&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">50001</span> <span class="hljs-comment">// 业务状态码</span><br>    <span class="hljs-attr">&quot;data&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">null</span></span><br><span class="hljs-attr">&quot;message&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;用户操作异常、xxx&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>自定义错误码，返回类支持返回正常和错误</p><h3 id="封装全局异常处理器"><a href="#封装全局异常处理器" class="headerlink" title="封装全局异常处理器"></a>封装全局异常处理器</h3><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><ol><li><p>定义业务异常类</p><ol><li>相对于 java 的异常类，支持更多字段</li><li>自定义构造函数，更灵活 &#x2F; 快捷的设置字段</li></ol></li><li><p>编写全局异常处理器（利用 Spring AOP，在调用方法前后进行额外的处理）</p></li></ol><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ol><li>捕获代码中所有的异常，内部消化，让前端得到更详细的业务报错 &#x2F; 信息</li><li>同时屏蔽掉项目框架本身的异常（不暴露服务器内部状态）</li><li>集中处理，比如记录日志</li></ol><h2 id="前端优化"><a href="#前端优化" class="headerlink" title="前端优化"></a>前端优化</h2><blockquote><p>直播的 0：00 - 0：35 为踩坑过程，可跳过</p></blockquote><h3 id="全局响应处理"><a href="#全局响应处理" class="headerlink" title="全局响应处理"></a>全局响应处理</h3><p>应用场景：我们需要对接口的 <strong>通用响应</strong> 进行统一处理，比如从 response 中取出 data；或者根据 code 去集中处理错误，比如用户未登录、没权限之类的。</p><p>优势：不用在每个接口请求中都去写相同的逻辑</p><p>实现：参考你用的请求封装工具的官方文档，比如 umi-request（<a href="https://github.com/umijs/umi-request#interceptor%E3%80%81https://blog.csdn.net/huantai3334/article/details/116780020%EF%BC%89%E3%80%82%E5%A6%82%E6%9E%9C%E4%BD%A0%E7%94%A8">https://github.com/umijs/umi-request#interceptor、https://blog.csdn.net/huantai3334/article/details/116780020）。如果你用</a> <strong>axios</strong>，参考 axios 的文档。</p><p>创建新的文件，在该文件中配置一个全局请求类。在发送请求时，使用我们自己的定义的全局请求类。</p><h2 id="用户校验"><a href="#用户校验" class="headerlink" title="用户校验"></a>用户校验</h2><blockquote><p>仅适用于用户可信的情况</p></blockquote><p>先让用户自己填：2 - 5 位编号，全凭自觉。</p><p>后台补充对编号的校验：长度校验、唯一性校验</p><p>前端补充输入框，适配后端。</p><blockquote><p>后期拉取星球数据，定期清理违规用户</p></blockquote><h2 id="多环境"><a href="#多环境" class="headerlink" title="多环境"></a>多环境</h2><p>参考文章：<a href="https://blog.csdn.net/weixin_41701290/article/details/120173283">https://blog.csdn.net/weixin_41701290/article/details/120173283</a></p><p>本地开发：localhost（127.0.0.1）</p><p>多环境：指同一套项目代码在不同的阶段需要根据实际情况来调整配置并且部署到不同的机器上。</p><p>为什么需要？</p><ol><li>每个环境互不影响</li><li>区分不同的阶段：开发 &#x2F; 测试 &#x2F; 生产</li><li>对项目进行优化：<ol><li>本地日志级别</li><li>精简依赖，节省项目体积</li><li>项目的环境 &#x2F; 参数可以调整，比如 JVM 参数</li></ol></li></ol><p>针对不同环境做不同的事情。</p><p>多环境分类：</p><ol><li>本地环境（自己的电脑）localhost</li><li>开发环境（远程开发）大家连同一台机器，为了大家开发方便</li><li>测试环境（测试）开发 &#x2F; 测试 &#x2F; 产品，单元测试 &#x2F; 性能测试 &#x2F; 功能测试 &#x2F; 系统集成测试，独立的数据库、独立的服务器</li><li>预发布环境（体验服）：和正式环境一致，正式数据库，更严谨，查出更多问题</li><li>正式环境（线上，公开对外访问的项目）：尽量不要改动，保证上线前的代码是 “完美” 运行</li><li>沙箱环境（实验环境）：为了做实验</li></ol><h3 id="前端多环境实战"><a href="#前端多环境实战" class="headerlink" title="前端多环境实战"></a>前端多环境实战</h3><ul><li><p>请求地址</p><ul><li><p>开发环境：localhost:8000</p></li><li><p>线上环境：user-backend.code-nav.cn</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">startFront</span>(<span class="hljs-params">env</span>) &#123;<br>    <span class="hljs-keyword">if</span>(env === <span class="hljs-string">&#x27;prod&#x27;</span>) &#123;<br>        <span class="hljs-comment">// 不输出注释 </span><br>        <span class="hljs-comment">// 项目优化</span><br>        <span class="hljs-comment">// 修改请求地址</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 保持本地开发逻辑</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>用了 umi 框架，build 时会自动传入 NODE_ENV &#x3D;&#x3D; production 参数，start NODE_ENV 参数为 development</p></li><li><p>启动方式</p><ul><li>开发环境：npm run start（本地启动，监听端口、自动更新）</li><li>线上环境：npm run build（项目构建打包），可以使用 serve 工具启动（npm i -g serve）</li></ul></li><li><p>项目的配置</p><p>不同的项目（框架）都有不同的配置文件，umi 的配置文件是 config，可以在配置文件后添加对应的环境名称后缀来区分开发环境和生产环境。参考文档：<a href="https://umijs.org/zh-CN/docs/deployment">https://umijs.org/zh-CN/docs/deployment</a></p><ul><li>开发环境：config.dev.ts</li><li>生产环境：config.prod.ts</li><li>公共配置：config.ts 不带后缀</li></ul></li></ul><h3 id="后端多环境实战"><a href="#后端多环境实战" class="headerlink" title="后端多环境实战"></a>后端多环境实战</h3><p>SpringBoot 项目，通过 application.yml 添加不同的后缀来区分配置文件</p><p>可以在启动项目时传入环境变量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">java -jar .\user-center-backend-0.0.1-SNAPSHOT.jar --spring.profiles.active=prod<br></code></pre></td></tr></table></figure><p>主要是改：</p><ul><li><p>依赖的环境地址</p><ul><li><p>数据库地址</p></li><li><p>缓存地址</p></li><li><p>消息队列地址</p></li><li><p>项目端口号</p></li></ul></li><li><p>服务器配置</p></li></ul><h2 id="项目部署"><a href="#项目部署" class="headerlink" title="项目部署"></a>项目部署</h2><p>参考文章：<a href="https://www.bilibili.com/read/cv16179200">https://www.bilibili.com/read/cv16179200</a></p><p>需要 Linux 服务器（建议大家用 CentOS 8+ &#x2F; 7.6 以上）</p><h3 id="原始部署"><a href="#原始部署" class="headerlink" title="原始部署"></a>原始部署</h3><p>什么都自己装</p><h4 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h4><p>需要 web 服务器：<strong>nginx</strong> 、apache、tomcat</p><p>安装 nginx 服务器：</p><ol><li><p>用系统自带的软件包管理器快速安装，比如 centos 的 yum</p></li><li><p>自己到官网安装（参考文章）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -o nginx-1.21.6.tar.gz http://nginx.org/download/nginx-1.21.6.tar.gz<br><br>tar -zxvf nginx-1.21.6.tar.gz<br><br><span class="hljs-built_in">cd</span> nginx-1.21.6<br><br>   37  2022-04-17 23:30:09 yum install pcre pcre-devel -y<br>   39  2022-04-17 23:30:59 yum install openssl openssl-devel -y<br>   41  2022-04-17 23:31:57 ./configure --with-http_ssl_module --with-http_v2_module --with-stream<br>   42  2022-04-17 23:32:13 make<br>   43  2022-04-17 23:32:54 make install<br>   48  2022-04-17 23:33:40 <span class="hljs-built_in">ls</span> /usr/local/nginx/sbin/nginx<br>   vim /etc/profile<br>  在最后一行添加：<span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>:/usr/local/nginx/sbin<br>  <br>  nginx<br>  <br>  netstat -ntlp 查看启动情况<br></code></pre></td></tr></table></figure><p>注意 nginx 权限</p></li></ol><h4 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h4><p>java、maven</p><p>安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum install -y java-1.8.0-openjdk*<br><br>curl -o apache-maven-3.8.5-bin.tar.gz https://dlcdn.apache.org/maven/maven-3/3.8.5/binaries/apache-maven-3.8.5-bin.tar.gz<br><br>git <span class="hljs-built_in">clone</span> xxx 下载代码<br><br>打包构建，跳过测试<br>mvn package -DskipTests<br><br>java -jar ./user-center-backend-0.0.1-SNAPSHOT.jar --spring.profiles.active=prod<br></code></pre></td></tr></table></figure><h3 id="宝塔-Linux-部署"><a href="#宝塔-Linux-部署" class="headerlink" title="宝塔 Linux 部署"></a>宝塔 Linux 部署</h3><p>Linux 运维面板</p><p>官方安装教程：<a href="https://www.bt.cn/new/download.html">https://www.bt.cn/new/download.html</a></p><p>方便管理服务器、方便安装软件</p><h3 id="前端托管"><a href="#前端托管" class="headerlink" title="前端托管"></a>前端托管</h3><p>前端腾讯云 web 应用托管（比容器化更傻瓜式，不需要自己写构建应用的命令，就能启动前端项目）</p><blockquote><p><a href="https://console.cloud.tencent.com/webify/new">https://console.cloud.tencent.com/webify/new</a></p></blockquote><ul><li>小缺点：需要将代码放到代码托管平台上</li><li>优势：不用写命令、代码更新时自动构建</li></ul><h3 id="Docker-部署"><a href="#Docker-部署" class="headerlink" title="Docker 部署"></a>Docker 部署</h3><p>docker 是容器，可以将项目的环境（比如 java、nginx）和项目的代码一起打包成镜像，所有同学都能下载镜像，更容易分发和移植。</p><p>再启动项目时，不需要敲一大堆命令，而是直接下载镜像、启动镜像就可以了。</p><p>docker 可以理解为软件安装包。</p><p>Docker 安装：<a href="https://www.docker.com/get-started/">https://www.docker.com/get-started/</a> 或者宝塔安装</p><p>Dockerfile 用于指定构建 Docker 镜像的方法</p><p>Dockerfile 一般情况下不需要完全从 0 自己写，建议去 github、gitee 等托管平台参考同类项目（比如 springboot）</p><p>Dockerfile 编写：</p><ul><li>FROM 依赖的基础镜像</li><li>WORKDIR 工作目录</li><li>COPY 从本机复制文件</li><li>RUN 执行命令</li><li>CMD &#x2F; ENTRYPOINT（附加额外参数）指定运行容器时默认执行的命令</li></ul><p>根据 Dockerfile 构建镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 后端</span><br>docker build -t user-center-backend:v0.0.1 .<br><br><span class="hljs-comment"># 前端</span><br>docker build -t user-center-front:v0.0.1 .<br></code></pre></td></tr></table></figure><p>Docker 构建优化：减少尺寸、减少构建时间（比如多阶段构建，可以丢弃之前阶段不需要的内容）</p><p>docker run 启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 前端</span><br>docker run -p 80:80 -d user-center-frontend:v0.0.1<br><br><span class="hljs-comment"># 后端</span><br>docker run -p 8080:8080 user-center-backend:v0.0.1<br></code></pre></td></tr></table></figure><p>虚拟化</p><ol><li>端口映射：把本机的资源（实际访问地址）和容器内部的资源（应用启动端口）进行关联</li><li>目录映射：把本机的端口和容器应用的端口进行关联</li></ol><p>进入容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -i -t  fee2bbb7c9ee /bin/bash<br></code></pre></td></tr></table></figure><p>查看进程：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker ps <br></code></pre></td></tr></table></figure><p>查看日志：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker logs -f [container-id]<br></code></pre></td></tr></table></figure><p>杀死容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">kill</span><br></code></pre></td></tr></table></figure><p>强制删除镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker rmi -f<br></code></pre></td></tr></table></figure><h3 id="Docker-平台部署"><a href="#Docker-平台部署" class="headerlink" title="Docker 平台部署"></a>Docker 平台部署</h3><ol><li>云服务商的容器平台（腾讯云、阿里云）</li><li>面向某个领域的容器平台（前端 &#x2F; 后端微信云托管）<strong>要花钱！</strong></li></ol><p>容器平台的好处：</p><ol><li>不用输命令来操作，更方便省事</li><li>不用在控制台操作，更傻瓜式、更简单</li><li>大厂运维，比自己运维更省心</li><li>额外的能力，比如监控、告警、其他（存储、负载均衡、自动扩缩容、流水线）</li></ol><p>爽就完事了！！！</p><h2 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h2><p>前端项目访问流程：用户输入网址 &#x3D;&gt; 域名解析服务器（把网址解析为 ip 地址 &#x2F; 交给其他的域名解析服务） &#x3D;&gt; 服务器 &#x3D;&gt;（防火墙）&#x3D;&gt; nginx 接收请求，找到对应的文件，返回文件给前端 &#x3D;&gt; 前端加载文件到浏览器中（js、css） &#x3D;&gt; 渲染页面</p><p>后端项目访问流程：用户输入网址 &#x3D;&gt; 域名解析服务器 &#x3D;&gt; 服务器 &#x3D;&gt; nginx 接收请求 &#x3D;&gt; 后端项目（比如 8080端口）</p><p>nginx 反向代理的作用：替服务器接收请求，转发请求</p><h2 id="跨域问题解决"><a href="#跨域问题解决" class="headerlink" title="跨域问题解决"></a>跨域问题解决</h2><p>浏览器为了用户的安全，仅允许向 <strong>同域名、同端口</strong> 的服务器发送请求。</p><p>如何解决跨域？</p><p>最直接的方式：把域名、端口改成相同的</p><h3 id="添加跨域头"><a href="#添加跨域头" class="headerlink" title="添加跨域头"></a>添加跨域头</h3><p>让服务器告诉浏览器：允许跨域（返回 cross-origin-allow 响应头）</p><h4 id="1-网关支持（Nginx）"><a href="#1-网关支持（Nginx）" class="headerlink" title="1. 网关支持（Nginx）"></a>1. 网关支持（Nginx）</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># 跨域配置</span><br><span class="hljs-section">location</span><span class="hljs-regexp"> ^~</span> /api/ &#123;<br>    <span class="hljs-attribute">proxy_pass</span> http://127.0.0.1:8080/api/;<br>    <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span> <span class="hljs-variable">$http_origin</span>;<br>    <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Access-Control-Allow-Credentials&#x27;</span> <span class="hljs-string">&#x27;true&#x27;</span>;<br>    <span class="hljs-attribute">add_header</span> Access-Control-Allow-Methods <span class="hljs-string">&#x27;GET, POST, OPTIONS&#x27;</span>;<br>    <span class="hljs-attribute">add_header</span> Access-Control-Allow-Headers <span class="hljs-string">&#x27;*&#x27;</span>;<br>    <span class="hljs-attribute">if</span> (<span class="hljs-variable">$request_method</span> = <span class="hljs-string">&#x27;OPTIONS&#x27;</span>) &#123;<br>        <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Access-Control-Allow-Credentials&#x27;</span> <span class="hljs-string">&#x27;true&#x27;</span>;<br>        <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span> <span class="hljs-variable">$http_origin</span>;<br>        <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Access-Control-Allow-Methods&#x27;</span> <span class="hljs-string">&#x27;GET, POST, OPTIONS&#x27;</span>;<br>        <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Access-Control-Allow-Headers&#x27;</span> <span class="hljs-string">&#x27;DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range&#x27;</span>;<br>        <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Access-Control-Max-Age&#x27;</span> <span class="hljs-number">1728000</span>;<br>        <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Content-Type&#x27;</span> <span class="hljs-string">&#x27;text/plain; charset=utf-8&#x27;</span>;<br>        <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Content-Length&#x27;</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-attribute">return</span> <span class="hljs-number">204</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-修改后端服务"><a href="#2-修改后端服务" class="headerlink" title="2. 修改后端服务"></a>2. 修改后端服务</h4><ol><li><p>配置 @CrossOrigin 注解</p></li><li><p>添加 web 全局请求拦截器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebMvcConfg</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br> <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addCorsMappings</span><span class="hljs-params">(CorsRegistry registry)</span> &#123;<br>        <span class="hljs-comment">//设置允许跨域的路径</span><br>        registry.addMapping(<span class="hljs-string">&quot;/**&quot;</span>)<br>                <span class="hljs-comment">//设置允许跨域请求的域名</span><br>                <span class="hljs-comment">//当**Credentials为true时，**Origin不能为星号，需为具体的ip地址【如果接口不带cookie,ip无需设成具体ip】</span><br>                .allowedOrigins(<span class="hljs-string">&quot;http://localhost:9527&quot;</span>, <span class="hljs-string">&quot;http://127.0.0.1:9527&quot;</span>, <span class="hljs-string">&quot;http://127.0.0.1:8082&quot;</span>, <span class="hljs-string">&quot;http://127.0.0.1:8083&quot;</span>)<br>                <span class="hljs-comment">//是否允许证书 不再默认开启</span><br>                .allowCredentials(<span class="hljs-literal">true</span>)<br>                <span class="hljs-comment">//设置允许的方法</span><br>                .allowedMethods(<span class="hljs-string">&quot;*&quot;</span>)<br>                <span class="hljs-comment">//跨域允许时间</span><br>                .maxAge(<span class="hljs-number">3600</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>定义新的 corsFilter Bean，参考：<a href="https://www.jianshu.com/p/b02099a435bd">https://www.jianshu.com/p/b02099a435bd</a></p></li></ol><h2 id="项目优化点"><a href="#项目优化点" class="headerlink" title="项目优化点"></a>项目优化点</h2><ol><li>功能扩充<ol><li>管理员创建用户、修改用户信息、删除用户</li><li>上传头像</li><li>按照更多的条件去查询用户</li><li>更改权限</li></ol></li><li>修改 Bug</li><li>项目登录改为分布式 session（单点登录 - redis）</li><li>通用性<ol><li>set-cookie domain 域名更通用，比如改为 *.xxx.com</li><li>把用户管理系统 &#x3D;&gt; 用户中心（之后所有的服务都请求这个后端）</li></ol></li><li>后台添加全局请求拦截器（统一去判断用户权限、统一记录请求日志）</li></ol>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>SpringBoot</tag>
      
      <tag>springmvc</tag>
      
      <tag>MybatisPlus</tag>
      
      <tag>MySQL</tag>
      
      <tag>React</tag>
      
      <tag>Ant Design Pro</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>瑞吉外卖项目笔记</title>
    <link href="/article/c8278629/"/>
    <url>/article/c8278629/</url>
    
    <content type="html"><![CDATA[<h1 id="瑞吉外卖项目笔记"><a href="#瑞吉外卖项目笔记" class="headerlink" title="瑞吉外卖项目笔记"></a>瑞吉外卖项目笔记</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这是一份写给自己的笔记，主要记录瑞吉外卖项目中自己没有了解过的知识点。我将按照功能来分别解析</p><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><p>除了基本的Controller,Service,Mapper,Config,Util,Entity层之外，还有我之前没了解过的common层和dto层</p><p>common层包含整个应用程序使用的公共辅助方法，和util层类似，但更有普适性，common层类中的方法对绝大多数功能都有辅助作用，如R类的作用是返回给前端通用格式的结果，能简化整个controller类的开发</p><p>dto层，DTO全称为<strong>Data Transfer Object</strong>,数据传输对象，起到数据封装与隔离的作用</p><h2 id="common层工具"><a href="#common层工具" class="headerlink" title="common层工具"></a>common层工具</h2><h3 id="返回结果类R"><a href="#返回结果类R" class="headerlink" title="返回结果类R"></a>返回结果类R</h3><p>此类是一个通用结果类，服务端响应的所有结果最终都会包装成此种类型返回给前端页面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> lombok.Data;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 通用返回结果，服务端响应的数据最终都会封装成此对象</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &lt;T&gt;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">R</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">private</span> Integer code; <span class="hljs-comment">//编码：1成功，0和其它数字为失败</span><br>    <span class="hljs-keyword">private</span> String msg; <span class="hljs-comment">//错误信息</span><br>    <span class="hljs-keyword">private</span> T data; <span class="hljs-comment">//数据</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Map</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>(); <span class="hljs-comment">//动态数据</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; R&lt;T&gt; <span class="hljs-title function_">success</span><span class="hljs-params">(T object)</span> &#123;<br>        R&lt;T&gt; r = <span class="hljs-keyword">new</span> <span class="hljs-title class_">R</span>&lt;T&gt;();<br>        r.data = object;<br>        r.code = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> r;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; R&lt;T&gt; <span class="hljs-title function_">error</span><span class="hljs-params">(String msg)</span> &#123;<br>        <span class="hljs-type">R</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">R</span>();<br>        r.msg = msg;<br>        r.code = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> r;<br>    &#125;<br>    <span class="hljs-keyword">public</span> R&lt;T&gt; <span class="hljs-title function_">add</span><span class="hljs-params">(String key, Object value)</span> &#123;<br>        <span class="hljs-built_in">this</span>.map.put(key, value);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//A. 如果业务执行结果为成功, 构建R对象时, 只需要调用 success 方法; 如果需要返回数据传递 object 参数, 如果无需返回, 可以直接传递null。</span><br><br><span class="hljs-comment">//B. 如果业务执行结果为失败, 构建R对象时, 只需要调用error 方法, 传递错误提示信息即可。</span><br></code></pre></td></tr></table></figure><h2 id="业务逻辑"><a href="#业务逻辑" class="headerlink" title="业务逻辑"></a>业务逻辑</h2><h3 id="新增信息"><a href="#新增信息" class="headerlink" title="新增信息"></a>新增信息</h3><p>以前的项目中，我在Controller方法中设置形参都是把一个个字段设置为形参，然后在DAO层分别写每个字段的添加方法，这样十分麻烦，我们可以把接收的形参设置为JSON实体类对象，再由mabatis-plus自动生成sql语句，就能省很多事了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> R&lt;AddressBook&gt; <span class="hljs-title function_">save</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> AddressBook addressBook)</span> &#123;&#125;<br></code></pre></td></tr></table></figure><h3 id="菜品分页查询"><a href="#菜品分页查询" class="headerlink" title="菜品分页查询"></a>菜品分页查询</h3><p>在前端回显数据时，我们要回显菜品分类的名称，但是菜品名称不在Dish这张表中，因此Dish实体类中也没有菜品名称的字段，因此我们用DishDto来扩展Dish,来辅助后端给前端发数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DishDto</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Dish</span> &#123;<br>    <span class="hljs-keyword">private</span> List&lt;DishFlavor&gt; flavors = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> String categoryName; <span class="hljs-comment">//菜品分类名称</span><br>    <span class="hljs-keyword">private</span> Integer copies;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/page&quot;)</span><br><span class="hljs-keyword">public</span> R&lt;Page&gt; <span class="hljs-title function_">page</span><span class="hljs-params">(<span class="hljs-type">int</span> page,<span class="hljs-type">int</span> pageSize,String name)</span>&#123;<br>    <span class="hljs-comment">//构造分页构造器对象</span><br>    Page&lt;Dish&gt; pageInfo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Page</span>&lt;&gt;(page,pageSize);<br>    Page&lt;DishDto&gt; dishDtoPage = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Page</span>&lt;&gt;();<br><br>    <span class="hljs-comment">//条件构造器</span><br>    LambdaQueryWrapper&lt;Dish&gt; queryWrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LambdaQueryWrapper</span>&lt;&gt;();<br>    <span class="hljs-comment">//添加过滤条件</span><br>    queryWrapper.like(name != <span class="hljs-literal">null</span>,Dish::getName,name);<br>    <span class="hljs-comment">//添加排序条件</span><br>    queryWrapper.orderByDesc(Dish::getUpdateTime);<br><br>    <span class="hljs-comment">//执行分页查询</span><br>    dishService.page(pageInfo,queryWrapper);<span class="hljs-comment">//查询后的数据存在pageInfo里</span><br><br>    <span class="hljs-comment">//对象拷贝</span><br>    BeanUtils.copyProperties(pageInfo,dishDtoPage,<span class="hljs-string">&quot;records&quot;</span>);<span class="hljs-comment">//records属性就是分页构造对象查询的分页数据，我们拷贝一份对象给新的分页构造器，但是我们要忽略records这个属性，因为我们要自己构建新的分页数据，也就是把菜品名称查出来并放到页面构造器中</span><br>    List&lt;Dish&gt; records = pageInfo.getRecords();<br>    List&lt;DishDto&gt; list = records.stream().map((item) -&gt; &#123;<span class="hljs-comment">//stream流遍历并构建新的list</span><br>        <br>        <span class="hljs-type">DishDto</span> <span class="hljs-variable">dishDto</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DishDto</span>();<br>        BeanUtils.copyProperties(item,dishDto);<br>        <span class="hljs-type">Long</span> <span class="hljs-variable">categoryId</span> <span class="hljs-operator">=</span> item.getCategoryId();<span class="hljs-comment">//分类id</span><br>        <span class="hljs-comment">//根据id查询分类对象</span><br>        <span class="hljs-type">Category</span> <span class="hljs-variable">category</span> <span class="hljs-operator">=</span> categoryService.getById(categoryId);<br>        <br>        <span class="hljs-keyword">if</span>(category != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">categoryName</span> <span class="hljs-operator">=</span> category.getName();<br>            dishDto.setCategoryName(categoryName);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dishDto;<span class="hljs-comment">//每修改完一个新元素都要返回该元素，然后才能由collect()方法整合成新列表</span><br>    &#125;).collect(Collectors.toList());<br>    dishDtoPage.setRecords(list);<span class="hljs-comment">//给新构造器设置我们自己修改过的分页数据</span><br>    <br>    <span class="hljs-keyword">return</span> R.success(dishDtoPage);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="其他技术要点"><a href="#其他技术要点" class="headerlink" title="其他技术要点"></a>其他技术要点</h2><h3 id="前端知识"><a href="#前端知识" class="headerlink" title="前端知识"></a>前端知识</h3><h4 id="localStorage和SessionStorage的区别："><a href="#localStorage和SessionStorage的区别：" class="headerlink" title="localStorage和SessionStorage的区别："></a>localStorage和SessionStorage的区别：</h4><p>localStorage 和 sessionStorage 属性允许在浏览器中存储 key&#x2F;value 对的数据。</p><p>localStorage 用于长久保存整个网站的数据，保存的数据没有过期时间，直到手动去删除。</p><p>localStorage 属性是只读的。</p><p>如果你只想将数据保存在当前会话中，可以使用 <a href="https://www.runoob.com/jsref/prop-win-sessionstorage.html">sessionStorage</a> 属性， 该数据对象临时保存同一窗口(或标签页)的数据，在关闭窗口或标签页之后将会删除这些数据。</p><h3 id="JS对长整型数据进行处理时会损失精度"><a href="#JS对长整型数据进行处理时会损失精度" class="headerlink" title="JS对长整型数据进行处理时会损失精度"></a>JS对长整型数据进行处理时会损失精度</h3><p>因此当我们数据库中id为长整型时，把id交给前端之前，先把id转成String类型，这样就不会损失精度了</p><h3 id="java基础"><a href="#java基础" class="headerlink" title="java基础"></a>java基础</h3><h4 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h4><p><a href="https://blog.csdn.net/huangjhai/article/details/107110182?ops_request_misc=%7B%22request_id%22:%22166177445516780357272081%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=166177445516780357272081&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-107110182-null-null.142%5Ev42%5Epc_ran_alice,185%5Ev2%5Etag_show&utm_term=lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F&spm=1018.2226.3001.4187">Lambda表达式超详细总结_Code0cean的博客-CSDN博客_lambda表达式详细总结</a></p><p>Lambda表达式简化了函数式接口（只有一个抽象方法的接口）的实现操作，用Lambda表达式可以很快地创建函数式接口的实现对象。</p><p>当要传递给Lambda体的操作，已经有实现的方法了，就可以使用方法引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Comparator&lt;Integer&gt; comparable=(x,y)-&gt;Integer.compare(x,y);<br>    <br>Comparator&lt;Integer&gt; integerComparable=Integer::compare;<span class="hljs-comment">//使用方法引用实现相同效果</span><br></code></pre></td></tr></table></figure><h4 id="Stream-流"><a href="#Stream-流" class="headerlink" title="Stream 流"></a>Stream 流</h4><p><a href="https://www.runoob.com/java/java8-streams.html">Java 8 Stream | 菜鸟教程 (runoob.com)</a></p><p><a href="https://blog.csdn.net/mu_wind/article/details/109516995?ops_request_misc=%7B%22request_id%22:%22166195746216782248513459%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=166195746216782248513459&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-109516995-null-null.142%5Ev44%5Epc_ran_alice&utm_term=stream%E6%B5%81&spm=1018.2226.3001.4187">Java8 Stream：2万字20个实例，玩转集合的筛选、归约、分组、聚合_云深i不知处的博客-CSDN博客_java stream 分组聚合</a></p><blockquote><p>Java 8 API添加了一个新的抽象称为流Stream，可以让你以一种声明的方式处理数据。</p><p>Stream 使用一种类似用 SQL 语句从数据库查询数据的直观方式来提供一种对 Java 集合运算和表达的高阶抽象。</p><p>Stream API可以极大提高Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。</p><p>这种风格将要处理的元素集合看作一种流， 流在管道中传输， 并且可以在管道的节点上进行处理， 比如筛选， 排序，聚合等。</p><p>元素流在管道中经过中间操作（intermediate operation）的处理，最后由最终操作(terminal operation)得到前面处理的结果。</p></blockquote><h3 id="全局异常处理"><a href="#全局异常处理" class="headerlink" title="全局异常处理"></a>全局异常处理</h3><p>使用全局异常处理可以避免重复在每一个业务逻辑里面写try…catch来捕获异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 全局异常处理</span><br><span class="hljs-comment"> 在项目中自定义一个全局异常处理器，在异常处理器上加上注解 <span class="hljs-doctag">@ControllerAdvice</span>,可以通过属性annotations指定拦截哪一类的Controller方法。 并在异常处理器的方法上加上注解 <span class="hljs-doctag">@ExceptionHandler</span> 来指定拦截的是那一类型的异常。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@ControllerAdvice(annotations = &#123;RestController.class, Controller.class&#125;)</span><br><span class="hljs-meta">@ResponseBody</span><span class="hljs-comment">//用这个注解可以将返回值R对象以JSON格式响应给页面</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span>  <span class="hljs-title class_">GlobalExceptionHandler</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 异常处理方法</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@ExceptionHandler(SQLIntegrityConstraintViolationException.class)</span><span class="hljs-comment">//声明拦截异常的类型</span><br>    <span class="hljs-keyword">public</span> R&lt;String&gt; <span class="hljs-title function_">exceptionHandler</span><span class="hljs-params">(SQLIntegrityConstraintViolationException ex)</span>&#123;<br>        log.error(ex.getMessage());<br>        <span class="hljs-keyword">if</span>(ex.getMessage().contains(<span class="hljs-string">&quot;Duplicate entry&quot;</span>))&#123;<br>            String[] split = ex.getMessage().split(<span class="hljs-string">&quot; &quot;</span>);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> split[<span class="hljs-number">2</span>] + <span class="hljs-string">&quot;已存在&quot;</span>;<br>            <span class="hljs-keyword">return</span> R.error(msg);<br>        &#125;<br>        <span class="hljs-keyword">return</span> R.error(<span class="hljs-string">&quot;未知错误&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="自定义业务异常类"><a href="#自定义业务异常类" class="headerlink" title="自定义业务异常类"></a>自定义业务异常类</h4><p>我们可以通过自定义业务异常类来抛出自定义的信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 自定义业务异常类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RuntimeException</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CustomException</span><span class="hljs-params">(String message)</span>&#123;<br>        <span class="hljs-built_in">super</span>(message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用时代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CustomException</span>(<span class="hljs-string">&quot;当前分类下关联了套餐，不能删除&quot;</span>);<span class="hljs-comment">//已经关联套餐，抛出一个业务异常</span><br></code></pre></td></tr></table></figure><p>在全局异常处理器中捕获自定义异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ExceptionHandler(CustomException.class)</span><br><span class="hljs-keyword">public</span> R&lt;String&gt; <span class="hljs-title function_">exceptionHandler</span><span class="hljs-params">(CustomException ex)</span>&#123;<br>    log.error(ex.getMessage());<br>    <span class="hljs-keyword">return</span> R.error(ex.getMessage());<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Serliazeable"><a href="#Serliazeable" class="headerlink" title="Serliazeable"></a>Serliazeable</h3><p>在Redis中存储对象，该对象是需要被序列化的，而对象要想被成功的序列化，就必须得实现 Serializable 接口.Java 序列化技术可以使你将一个对象的状态写入一个Byte 流里（系列化），并且可以从其它地方把该Byte 流里的数据读出来（反序列化）</p><p>只要让类继承Serialzable接口就可以实现序列化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">R</span>&lt;T&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span>&#123;<br></code></pre></td></tr></table></figure><h3 id="Spring-基础"><a href="#Spring-基础" class="headerlink" title="Spring 基础"></a>Spring 基础</h3><h4 id="接收前端发来的JSON数据"><a href="#接收前端发来的JSON数据" class="headerlink" title="接收前端发来的JSON数据"></a>接收前端发来的JSON数据</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//接收前端发来的JSON数据，需要在相应形参前加@RequestBody注解，因为JSON数据在请求体中被发过来</span><br><span class="hljs-keyword">public</span> R&lt;Employee&gt; <span class="hljs-title function_">login</span><span class="hljs-params">(HttpServletRequest request,<span class="hljs-meta">@RequestBody</span> Employee employee)</span>&#123;&#125;<br></code></pre></td></tr></table></figure><h4 id="Springboot中-json序列化与反序列化"><a href="#Springboot中-json序列化与反序列化" class="headerlink" title="Springboot中 json序列化与反序列化"></a>Springboot中 json序列化与反序列化</h4><p>Springboot集成并封装了Jackson，使用Jackson来操作json，JSON的序列化与反序列化我们可以通过<code>@Responsebody</code>和<code>@RequestBody</code>轻松实现</p><h3 id="Lombok"><a href="#Lombok" class="headerlink" title="Lombok"></a>Lombok</h3><p>Lombok是一个可以减少java模板代码的工具，我们可以用Lombok来简化Entity类的代码，省去了get,set及构造方法，接下来介绍lombok的常用注解</p><h4 id="Data"><a href="#Data" class="headerlink" title="@Data"></a>@Data</h4><p>在Entity类中使用该注解，在项目编译时，会帮我们自动加上set,get以及toString方法</p><h4 id="Slf4j"><a href="#Slf4j" class="headerlink" title="@Slf4j"></a>@Slf4j</h4><p>在类上使用该注解，我们可以在类中的方法使用<code>log</code>函数来输出日志信息</p><h3 id="MybatisPlus"><a href="#MybatisPlus" class="headerlink" title="MybatisPlus"></a>MybatisPlus</h3><h4 id="条件构造器"><a href="#条件构造器" class="headerlink" title="条件构造器"></a>条件构造器</h4><p>顾名思义，作用就是封装查询条件，生成sql的where条件</p><p>在项目中，查询数据库用到了LambdaQuaryWrapper</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//2、根据页面提交的用户名username查询数据库</span><br>   LambdaQueryWrapper&lt;Employee&gt; queryWrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LambdaQueryWrapper</span>&lt;&gt;();<br>   queryWrapper.eq(Employee::getUsername,employee.getUsername());<span class="hljs-comment">//这里通过Lambda表达式来获取User实体类中username的字段名，省去了查数据库的步骤，这就是lambda条件构造器的优点</span><br>   <span class="hljs-type">Employee</span> <span class="hljs-variable">emp</span> <span class="hljs-operator">=</span> employeeService.getOne(queryWrapper);<span class="hljs-comment">//相当于里面放了一个查询语句，通过查询语句获取结果</span><br></code></pre></td></tr></table></figure><h4 id="公共字段填充"><a href="#公共字段填充" class="headerlink" title="公共字段填充"></a>公共字段填充</h4><p>数据库里经常需要填充一些公共字段，如用户id,更新时间等，我们可以把这些操作交给mybatis-plus自动完成</p><p>第一步去实体类给要自动填充的字段加注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//通过@tablefield声明要自动填充的注解，并指定填充策略</span><br> <span class="hljs-meta">@TableField(fill = FieldFill.INSERT)</span> <span class="hljs-comment">//插入时填充字段</span><br> <span class="hljs-keyword">private</span> LocalDateTime createTime;<br><br> <span class="hljs-meta">@TableField(fill = FieldFill.INSERT_UPDATE)</span> <span class="hljs-comment">//插入和更新时填充字段</span><br> <span class="hljs-keyword">private</span> LocalDateTime updateTime;<br><br> <span class="hljs-meta">@TableField(fill = FieldFill.INSERT)</span> <span class="hljs-comment">//插入时填充字段</span><br> <span class="hljs-keyword">private</span> Long createUser;<br><br> <span class="hljs-meta">@TableField(fill = FieldFill.INSERT_UPDATE)</span> <span class="hljs-comment">//插入和更新时填充字段</span><br> <span class="hljs-keyword">private</span> Long updateUser;<br><br></code></pre></td></tr></table></figure><p>第二步在common层添加自定义元数据对象处理器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyMetaObjecthandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MetaObjectHandler</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 插入操作，自动填充</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> metaObject</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertFill</span><span class="hljs-params">(MetaObject metaObject)</span> &#123;<span class="hljs-comment">//实现插入和更新对应的方法</span><br>        log.info(<span class="hljs-string">&quot;公共字段自动填充[insert]...&quot;</span>);<br>        log.info(metaObject.toString());<br><br>        metaObject.setValue(<span class="hljs-string">&quot;createTime&quot;</span>, LocalDateTime.now());<br>        metaObject.setValue(<span class="hljs-string">&quot;updateTime&quot;</span>,LocalDateTime.now());<br>        metaObject.setValue(<span class="hljs-string">&quot;createUser&quot;</span>,BaseContext.getCurrentId());<br>        metaObject.setValue(<span class="hljs-string">&quot;updateUser&quot;</span>,BaseContext.getCurrentId());<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 更新操作，自动填充</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> metaObject</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updateFill</span><span class="hljs-params">(MetaObject metaObject)</span> &#123;<br>        log.info(<span class="hljs-string">&quot;公共字段自动填充[update]...&quot;</span>);<br>        log.info(metaObject.toString());<br><br>        <span class="hljs-type">long</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> Thread.currentThread().getId();<br>        log.info(<span class="hljs-string">&quot;线程id为：&#123;&#125;&quot;</span>,id);<br><br>        metaObject.setValue(<span class="hljs-string">&quot;updateTime&quot;</span>,LocalDateTime.now());<br>        metaObject.setValue(<span class="hljs-string">&quot;updateUser&quot;</span>,BaseContext.getCurrentId());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是在MyMetaObjectHandler中，我们不能直接获取HttpSession对象，也就不能直接获取session中的用户ID,此项目采用ThreadLocal解决</p><h4 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h4><p>ThreadLocal并不是一个Thread，而是Thread的局部变量。当使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。</p><p>ThreadLocal为每个线程提供单独一份存储空间，具有线程隔离的效果，只有在线程内才能获取到对应的值，线程外则不能访问当前线程对应的值。</p><p>我们可以在LoginCheckFilter的doFilter方法中获取当前登录用户id，并调用ThreadLocal的set方法来设置当前线程的线程局部变量的值（用户id），然后在MyMetaObjectHandler的updateFill方法中调用ThreadLocal的get方法来获得当前线程所对应的线程局部变量的值（用户id）。 如果在后续的操作中, 我们需要在Controller &#x2F; Service中要使用当前登录用户的ID, 可以直接从ThreadLocal直接获取。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 基于ThreadLocal封装工具类，用户保存和获取当前登录用户id</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BaseContext</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ThreadLocal&lt;Long&gt; threadLocal = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;&gt;();<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 设置值</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> id</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCurrentId</span><span class="hljs-params">(Long id)</span>&#123;<br>        threadLocal.set(id);<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取值</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Long <span class="hljs-title function_">getCurrentId</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> threadLocal.get();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后我们在filter中判断用户的登录情况，放行前给ThreadLocal赋值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Long</span> <span class="hljs-variable">empId</span> <span class="hljs-operator">=</span> (Long) request.getSession().getAttribute(<span class="hljs-string">&quot;employee&quot;</span>);<br>BaseContext.setCurrentId(empId);<br></code></pre></td></tr></table></figure><p>然后我们就可以在各个地方获取ThreadLocal变量了</p><h2 id="项目优化"><a href="#项目优化" class="headerlink" title="项目优化"></a>项目优化</h2><h3 id="SpringCache"><a href="#SpringCache" class="headerlink" title="SpringCache"></a>SpringCache</h3><p>Spring Cache只是提供了一层抽象，底层可以切换不同的cache实现。具体就是通过<strong>CacheManager</strong>接口来统一不同的缓存技术。CacheManager是Spring提供的各种缓存技术抽象接口。</p><p>针对不同的缓存技术需要实现不同的CacheManager：</p><table><thead><tr><th><strong>CacheManager</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>EhCacheCacheManager</td><td>使用EhCache作为缓存技术</td></tr><tr><td>GuavaCacheManager</td><td>使用Google的GuavaCache作为缓存技术</td></tr><tr><td>RedisCacheManager</td><td>使用Redis作为缓存技术</td></tr></tbody></table><h4 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h4><p>在SpringCache中提供了很多缓存操作的注解，常见的是以下的几个：</p><table><thead><tr><th><strong>注解</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>@EnableCaching</td><td>开启缓存注解功能</td></tr><tr><td>@Cacheable</td><td>在方法执行前spring先查看缓存中是否有数据，如果有数据，则直接返回缓存数据；若没有数据，调用方法并将方法返回值放到缓存中</td></tr><tr><td>@CachePut</td><td>将方法的返回值放到缓存中</td></tr><tr><td>@CacheEvict</td><td>将一条或多条数据从缓存中删除</td></tr></tbody></table><p>在spring boot项目中，使用缓存技术只需在项目中导入相关缓存技术的依赖包，并在启动类上使用@EnableCaching开启缓存支持即可。</p><p>例如，使用Redis作为缓存技术，只需要导入Spring data Redis的maven坐标即可。</p><h4 id="CachePut注解"><a href="#CachePut注解" class="headerlink" title="@CachePut注解"></a>@CachePut注解</h4><blockquote><p>@CachePut 说明： </p><p>​作用: 将方法返回值，放入缓存</p><p>​value: 缓存的名称, 每个缓存名称下面可以有很多key</p><p>​key: 缓存的key  ———-&gt; 支持Spring的表达式语言SPEL语法</p></blockquote><p><strong>在save方法上加注解@CachePut</strong></p><p>当前UserController的save方法是用来保存用户信息的，我们希望在该用户信息保存到数据库的同时，也往缓存中缓存一份数据，我们可以在save方法上加上注解 @CachePut，用法如下： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* CachePut：将方法返回值放入缓存</span><br><span class="hljs-comment">* value：缓存的名称，每个缓存名称下面可以有多个key</span><br><span class="hljs-comment">* key：缓存的key</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">@CachePut(value = &quot;userCache&quot;, key = &quot;#user.id&quot;)</span><br><span class="hljs-meta">@PostMapping</span><br><span class="hljs-keyword">public</span> User <span class="hljs-title function_">save</span><span class="hljs-params">(User user)</span>&#123;<br>    userService.save(user);<br>    <span class="hljs-keyword">return</span> user;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>key的写法如下： </p><p>​#user.id : #user指的是方法形参的名称, id指的是user的id属性 , 也就是使用user的id属性作为key ;</p><p>​#user.name: #user指的是方法形参的名称, name指的是user的name属性 ,也就是使用user的name属性作为key ;</p></blockquote><h4 id="CacheEvict注解"><a href="#CacheEvict注解" class="headerlink" title="@CacheEvict注解"></a>@CacheEvict注解</h4><blockquote><p>@CacheEvict 说明： </p><p>​作用: 清理指定缓存</p><p>​value: 缓存的名称，每个缓存名称下面可以有多个key</p><p>​key: 缓存的key  ———-&gt; 支持Spring的表达式语言SPEL语法</p></blockquote><p><strong>在 delete 方法上加注解@CacheEvict</strong></p><p>当我们在删除数据库user表的数据的时候,我们需要删除缓存中对应的数据,此时就可以使用@CacheEvict注解, 具体的使用方式如下: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* CacheEvict：清理指定缓存</span><br><span class="hljs-comment">* value：缓存的名称，每个缓存名称下面可以有多个key</span><br><span class="hljs-comment">* key：缓存的key</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">@CacheEvict(value = &quot;userCache&quot;,key = &quot;#p0&quot;)</span>  <span class="hljs-comment">//#p0 代表第一个参数</span><br><span class="hljs-comment">//@CacheEvict(value = &quot;userCache&quot;,key = &quot;#root.args[0]&quot;) //#root.args[0] 代表第一个参数</span><br><span class="hljs-comment">//@CacheEvict(value = &quot;userCache&quot;,key = &quot;#id&quot;) //#id 代表变量名为id的参数</span><br><span class="hljs-meta">@DeleteMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">delete</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Long id)</span>&#123;<br>    userService.removeById(id);<br>&#125;<br></code></pre></td></tr></table></figure><p>在更新数据的时候也需要删除缓存，以免数据不同步</p><h4 id="Cacheable注解"><a href="#Cacheable注解" class="headerlink" title="@Cacheable注解"></a>@Cacheable注解</h4><blockquote><p>@Cacheable 说明:</p><p>​作用: 在方法执行前，spring先查看缓存中是否有数据，如果有数据，则直接返回缓存数据；若没有数据，调用方法并将方法返回值放到缓存中</p><p>​value: 缓存的名称，每个缓存名称下面可以有多个key</p><p>​key: 缓存的key  ———-&gt; 支持Spring的表达式语言SPEL语法</p></blockquote><p><strong>在getById上加注解@Cacheable</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Cacheable：在方法执行前spring先查看缓存中是否有数据，如果有数据，则直接返回缓存数据；若没有数据，调用方法并将方法返回值放到缓存中</span><br><span class="hljs-comment">* value：缓存的名称，每个缓存名称下面可以有多个key</span><br><span class="hljs-comment">* key：缓存的key</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">@Cacheable(value = &quot;userCache&quot;,key = &quot;#id&quot;)</span><br><span class="hljs-meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="hljs-keyword">public</span> User <span class="hljs-title function_">getById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Long id)</span>&#123;<br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> userService.getById(id);<br>    <span class="hljs-keyword">return</span> user;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>缓存非null值</strong></p><p>在@Cacheable注解中，提供了两个属性分别为： condition， unless 。</p><blockquote><p>condition : 表示满足什么条件, 再进行缓存 ;</p><p>unless : 表示满足条件则不缓存 ; 与上述的condition是反向的 ;</p></blockquote><p>具体实现方式如下: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Cacheable：在方法执行前spring先查看缓存中是否有数据，如果有数据，则直接返回缓存数据；若没有数据，调用方法并将方法返回值放到缓存中</span><br><span class="hljs-comment"> * value：缓存的名称，每个缓存名称下面可以有多个key</span><br><span class="hljs-comment"> * key：缓存的key</span><br><span class="hljs-comment"> * condition：条件，满足条件时才缓存数据</span><br><span class="hljs-comment"> * unless：满足条件则不缓存</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Cacheable(value = &quot;userCache&quot;,key = &quot;#id&quot;, unless = &quot;#result == null&quot;)</span><br><span class="hljs-meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="hljs-keyword">public</span> User <span class="hljs-title function_">getById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Long id)</span>&#123;<br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> userService.getById(id);<br>    <span class="hljs-keyword">return</span> user;<br>&#125;<br></code></pre></td></tr></table></figure><p>&#x3D;&#x3D;注意： 此处，我们使用的时候只能够使用 unless， 因为在condition中，我们是无法获取到结果 #result的。&#x3D;&#x3D;</p><h3 id="MySQL主从数据库"><a href="#MySQL主从数据库" class="headerlink" title="MySQL主从数据库"></a>MySQL主从数据库</h3><blockquote><p>面对日益增加的系统访问量，数据库的吞吐量面临着巨大瓶颈。 对于同一时刻有大量并发读操作和较少写操作类型的应用系统来说，将数据库拆分为<strong>主库</strong>和<strong>从库</strong>，主库负责处理事务性的增删改操作，从库负责处理查询操作，能够有效的避免由数据更新导致的行锁，使得整个系统的查询性能得到极大的改善。 ——瑞吉外卖PPT</p></blockquote><h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><p><strong>以下内容摘自CSDN博客 <a href="https://blog.csdn.net/char_m/article/details/110188718">要不一起ci个饭的博客-CSDN博客_主从复制</a></strong></p><h4 id="主从复制的定义"><a href="#主从复制的定义" class="headerlink" title="主从复制的定义"></a>主从复制的定义</h4><p>主从复制，是用来建立一个和主数据库完全一样的数据库环境，称为从数据库。在赋值过程中，一个服务器充当主服务器，而另外一台服务器充当从服务器。<br>当一台从服务器连接到主服务器时，从服务器会通知主服务器从服务器的日志文件中读取最后一次成功更新的位置。然后从服务器会接收从哪个时刻起发生的任何更新，然后锁住并等到主服务器通知新的更新</p><h4 id="做主从复制的好处"><a href="#做主从复制的好处" class="headerlink" title="做主从复制的好处"></a>做主从复制的好处</h4><p>做数据的热备<br>作为后备数据库，主数据库服务器故障后，可切换到从数据库继续工作，避免数据丢失。</p><p>架构的扩展<br>业务量越来越大,I&#x2F;O访问频率过高，单机无法满足，此时做多库的存储，降低磁盘I&#x2F;O访问的评率，提高单个机器的I&#x2F;O性能。</p><p><strong>读写分离（重点）</strong><br>使数据库能支持更大的并发。在报表中尤其重要。由于部分报表sql语句非常的慢，导致锁表，影响前台服务。如果前台使用master，报表使用slave，那么报表sql将不会造成前台锁，保证了前台速度。</p><h3 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h3><p>面对日益增加的系统访问量，数据库的吞吐量面临着巨大瓶颈。 对于同一时刻有大量并发读操作和较少写操作类型的应用系统来说，将数据库拆分为<strong>主库</strong>和<strong>从库</strong>，主库负责处理事务性的增删改操作，从库负责处理查询操作，能够有效的避免由数据更新导致的行锁，使得整个系统的查询性能得到极大的改善。</p><h4 id="ShardingJDBC介绍"><a href="#ShardingJDBC介绍" class="headerlink" title="ShardingJDBC介绍"></a>ShardingJDBC介绍</h4><p>Sharding-JDBC定位为轻量级Java框架，在Java的JDBC层提供的额外服务。 它使用客户端直连数据库，以jar包形式提供服务，无需额外部署和依赖，可理解为增强版的JDBC驱动，完全兼容JDBC和各种ORM框架。</p><p>使用Sharding-JDBC可以在程序中轻松的实现数据库读写分离。</p><p>Sharding-JDBC具有以下几个特点： </p><p>1). 适用于任何基于JDBC的ORM框架，如：JPA, Hibernate, Mybatis, Spring JDBC Template或直接使用JDBC。</p><p>2). 支持任何第三方的数据库连接池，如：DBCP, C3P0, BoneCP, Druid, HikariCP等。</p><p>3). 支持任意实现JDBC规范的数据库。目前支持MySQL，Oracle，SQLServer，PostgreSQL以及任何遵循SQL92标准的数据库。</p><h3 id="Nginx-Swagger"><a href="#Nginx-Swagger" class="headerlink" title="Nginx,Swagger"></a>Nginx,Swagger</h3><p>重构项目的时候会详细学一下，目前看这些都是纸上谈兵。</p>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>SpringBoot</tag>
      
      <tag>MybatisPlus</tag>
      
      <tag>MySQL</tag>
      
      <tag>Redis</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>羽毛球比赛规则</title>
    <link href="/article/6db70910/"/>
    <url>/article/6db70910/</url>
    
    <content type="html"><![CDATA[<h1 id="羽毛球比赛规则"><a href="#羽毛球比赛规则" class="headerlink" title="羽毛球比赛规则"></a>羽毛球比赛规则</h1><h2 id="计分规则"><a href="#计分规则" class="headerlink" title="计分规则"></a>计分规则</h2><ul><li>21 分制，3局2胜为佳</li><li>每球得分制</li><li>每回合中，取胜的一方加 1 分</li><li>当双方均为 20 分时，领先对方 2 分的一方赢得该局比赛</li><li>当双方均为 29 分时，先取得 30 分的一方赢得该局比赛</li><li>一局比赛的获胜方在下一局率先发球</li></ul><h2 id="赛间休息与换边规则"><a href="#赛间休息与换边规则" class="headerlink" title="赛间休息与换边规则"></a>赛间休息与换边规则</h2><ul><li>在一局比赛中，当领先的一方达到 11 分时，双方有 60 秒休息时间</li><li>在两局比赛间，双方有 2 分钟的休息时间</li><li>在决胜局的中，当领先的一方达到 11 分时，双方交换场地</li></ul><h2 id="单打规则"><a href="#单打规则" class="headerlink" title="单打规则"></a>单打规则</h2><ul><li>在一局比赛开始时（比分 0 ： 0）或发球方得分为偶数时，发球方在右半场进行发球。当发球方得分为奇数时，在左半场进行发球</li><li>如果发球方取得一分，那么下一回合其继续发球</li><li>如果接发球方取得一分，那么下一回合其成为发球方</li></ul><h2 id="双打规则"><a href="#双打规则" class="headerlink" title="双打规则"></a>双打规则</h2><ul><li>与单打一样，发球方得分为偶数时，发球方在右半场进行发球。当发球方得分为奇数时，在左半场进行发球</li><li>如果发球方取得一分，那么下一回合其继续发球，且发球人不变</li><li>如果接发球方取得一分，那么下一回合其成为发球方</li><li>当且仅当发球方得分时，发球方的两位选手交换左右半场</li></ul><h2 id="双打规则图解"><a href="#双打规则图解" class="headerlink" title="双打规则图解"></a>双打规则图解</h2><p>下面描述一场 <strong>羽毛球双打比赛</strong> ，A &amp; B vs C &amp; D，比赛开始时，由A率先发球，C接发球</p><table><thead><tr><th align="left">比赛进程的说明</th><th align="left">比分</th><th align="left">发球区</th><th align="left">发球&amp;接发</th><th align="center">获胜方</th></tr></thead><tbody><tr><td align="left">比赛开始</td><td align="left">0 - 0</td><td align="left">右侧半场发球</td><td align="left">A发球，C接发球</td><td align="center">A &amp; B</td></tr><tr><td align="left">A &amp; B 得一分，A &amp; B 将换边， A在左侧半场继续发球， C &amp; D 保持各自所在半场不变。</td><td align="left">1 - 0</td><td align="left">左侧半场发球</td><td align="left">A发球，D接发球</td><td align="center">C &amp; D</td></tr><tr><td align="left">C &amp; D 得一分，A B C D 均保持各自所在半场不变。</td><td align="left">1 - 1</td><td align="left">左侧半场发球</td><td align="left">D发球，A接发球</td><td align="center">A &amp; B</td></tr><tr><td align="left">A &amp; B 得一分，在右半场发球，A B C D 均保持各自所在半场不变。</td><td align="left">2 - 1</td><td align="left">右侧半场发球</td><td align="left">B发球，C接发球</td><td align="center">C &amp; D</td></tr><tr><td align="left">C &amp; D 得一分，在右半场发球，A B C D 均保持各自所在半场不变。</td><td align="left">2 - 2</td><td align="left">右侧半场发球</td><td align="left">C发球，B接发球</td><td align="center">C &amp; D</td></tr><tr><td align="left">C &amp; D 得一分， C &amp; D 将换边， C 在左侧半场继续发球， A &amp; B 保持各自所在半场不变。</td><td align="left">2 - 3</td><td align="left">左侧半场发球</td><td align="left">C发球，A接发球</td><td align="center">A &amp; B</td></tr><tr><td align="left">A &amp; B 得一分，在左半场发球，A B C D 均保持各自所在半场不变。</td><td align="left">3 - 3</td><td align="left">左侧半场发球</td><td align="left">A发球，C接发球</td><td align="center">A &amp; B</td></tr><tr><td align="left">A &amp; B 得一分，A &amp; B 将换边， A在右侧半场继续发球， C &amp; D 保持各自所在半场不变。</td><td align="left">4 - 3</td><td align="left">右侧半场发球</td><td align="left">A发球，D接发球</td><td align="center">C &amp; D</td></tr></tbody></table><h2 id="羽毛球场地标准尺寸"><a href="#羽毛球场地标准尺寸" class="headerlink" title="羽毛球场地标准尺寸"></a>羽毛球场地标准尺寸</h2><ul><li>羽毛球场地应是一个长方形，用宽40毫米的线画出</li><li>场地线的颜色最好是白色、黄色或其他容易辨别的颜色</li><li>所有的线都是它所界定区域的组成部分</li><li>从球场地面起，网柱高1.55米</li><li>网柱必须稳固地同地面垂直，并使球网保持紧拉状态</li><li>网柱应放置在双打的边线上</li><li>羽毛球球网应由深色优质的细绳编织成，网孔为均匀分布的方形，边长15～20毫米</li><li>羽毛球球网上下宽760毫米</li><li>绳索或钢丝须有足够的长度和强度，能牢固地拉紧并与网柱顶部取平</li><li>场地中央网高1.524米，双打边线处网高1.55米</li><li>球网的两端必须与网柱系紧，它们之间不应有空隙</li><li>长13.40米，双打宽6.10米，单打宽5.18米，双打球场对角线长&#x3D;14.723米，单打球场对角线长&#x3D;14.366米</li></ul><p><img src="https://www.helloimg.com/images/2023/08/16/oSXduu.png"></p><h2 id="发球违例"><a href="#发球违例" class="headerlink" title="发球违例"></a>发球违例</h2><ul><li>未将球发在相应的区域内</li><li>球挂在网上或停在网顶</li><li>球过网后挂在网上</li><li>双打时，接发球员的同伴接到球或被球触及</li></ul><h2 id="比赛进行中违例"><a href="#比赛进行中违例" class="headerlink" title="比赛进行中违例"></a>比赛进行中违例</h2><ul><li>球落在场地界线外</li><li>球从网孔或网下穿过</li><li>球未从网上方越过</li><li>球触及天花板或四周墙壁</li><li>球触及运动员的身体或衣服</li><li>球触及场地外其他物体或人</li><li>球被击时停滞在球拍上，紧接着被拖带抛出</li><li>球在一个回合中被同一方队员多次击中</li><li>运动员的球拍、身体或衣服，触及球网或球网的支撑物</li><li>过网击球(击球时，球拍与球的最初接触点在击球者网这一方，而后球拍随球过网的情况除外)</li></ul><h2 id="羽毛球发球区域"><a href="#羽毛球发球区域" class="headerlink" title="羽毛球发球区域"></a>羽毛球发球区域</h2><ul><li>单打发球有效区域为下图中的蓝色区域</li><li>双打发球有效区域为下图中的绿色区域</li></ul><p><img src="https://www.helloimg.com/images/2023/08/16/oSX0cE.png" alt="羽毛球比赛规则 发球有效区域"></p><h2 id="羽毛球半场边线"><a href="#羽毛球半场边线" class="headerlink" title="羽毛球半场边线"></a>羽毛球半场边线</h2><ul><li>单打时，半场边线有效范围是下图中的蓝色区域</li><li>双打时，半场边线有效范围是下图中的绿色区域</li></ul><p><img src="https://www.helloimg.com/images/2023/08/16/oSXNrY.png" alt="羽毛球比赛规则 半场边线范围"></p><h2 id="羽毛球拍的磅数与操控感"><a href="#羽毛球拍的磅数与操控感" class="headerlink" title="羽毛球拍的磅数与操控感"></a>羽毛球拍的磅数与操控感</h2><p>羽毛球拍磅数是指羽线张力（1磅 &#x3D; 453.6克，20磅等于为9公斤），羽毛球拍想要承受更高的重量，材料就要求更好、做工要求更精细，当然成本也就更高，价格更贵。</p><ul><li>磅数低的羽毛球拍弹性较大，在后场发力与借力防守会比较轻松，但是羽毛球飞行线路和落点，以及网前小球难以控制。</li><li>磅数高的羽毛球拍拍面较硬，可以精准的控制羽毛球飞行线路和落点，进攻速度快，网前小球控制更容易，但是对羽毛球拍的使用者有着更高的技术要求，特别是手腕的力量。</li><li>随着自身羽毛球技术的提升，可以考虑更换更优质的羽毛球拍，并为羽毛球拍拉更高磅数的拍线。</li></ul>]]></content>
    
    
    <categories>
      
      <category>羽毛球</category>
      
    </categories>
    
    
    <tags>
      
      <tag>羽毛球比赛规则</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HashMap</title>
    <link href="/article/3d614825/"/>
    <url>/article/3d614825/</url>
    
    <content type="html"><![CDATA[<h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><h2 id="HashMap概念"><a href="#HashMap概念" class="headerlink" title="HashMap概念"></a>HashMap概念</h2><p>HashMap是基于哈希表的Map接口的非同步实现。HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。数组被分为一个个桶（bucket），每个桶存储有一个或多个Entry对象，每个Entry对象包含三部分key（键）、value（值），next(指向下一个Entry），通过哈希值决定了Entry对象在这个数组的寻址；哈希值相同的Entry对象（键值对），则以链表形式存储。如果链表大小超过树形转换的阈（TREEIFY_THRESHOLD&#x3D; 8），链表就会被改造为树形结构。对于HashMap中的每个key，首先通过哈希算法计算出一个哈希值，这个哈希值就代表了在桶里里的编号，而桶本身实际上是用数组来实现的，所以把这个数值模上数组的长度得到它在数组的index，就这样把它放在了数组里。</p><p>再看一下数组、链表的优缺点。</p><p>数组：数组删除、插入性能不佳，寻址性能极优</p><p>链表：链表查询性能不佳，删除、插入性能极优 数组的优缺点取决于它在内存中存储的模式，也就是直接使用顺序存储或链式存储导致的。无论是数组还是链表，都有明显的缺点。</p><p>散列表：散列表是一个根据key来访问value的存储结构，HashMap中实现的散列表是一个链表类型的数组，即数组+链表，用来存储key-value数据对。</p><h2 id="HashMap原理与存储"><a href="#HashMap原理与存储" class="headerlink" title="HashMap原理与存储"></a>HashMap原理与存储</h2><p>hashMap的主干是一个Entry数组。Entry是HashMap的基本组成单元，每一个Entry包含一个key-value键值对。基本原理：先声明一个下标范围比较大的数组来存储元素。另外设计一个哈希函数（也叫做散列函数）来获得每一个元素的Key（关键字）的函数值（即数组下标，hash值）相对应，数组存储的元素是一个Entry类，这个类有三个数据域，key、value（键值对），next(指向下一个Entry)。</p><p>举例：第一个键值对A1进来。通过计算其key的hash得到的index&#x3D;0。存储为:Entry[0] &#x3D; A1。 第二个键值对A2，通过计算其index也等于0， HashMap会将A2.next &#x3D;A1,Entry[0] &#x3D;A2, 第三个键值对 A3,index也等于0,那么A3.next &#x3D; A2,Entry[0] &#x3D;A3；可以看到index&#x3D;0的地方事实上存取了A1,A2,A3三个键值对,它们通过next这个属性链接在一起。这就是桶。对于不同的元素，可能计算出了相同的函数值，这样就产生了“冲突”，这就需要解决冲突，“直接定址”与“解决冲突”是哈希表的两大特点。而HashMap中的链表主要为了解决哈希冲突而存在的，如果定位到的数组位置不含链表（当前entry的next指向null）,那么对于查找，添加等操作很快，仅需一次寻址即可；如果定位到的数组包含链表，对于添加操作，其时间复杂度为O(n)，首先遍历链表，存在即覆盖，否则新增；对于查找操作来讲，仍需遍历链表，然后通过key对象的equals方法逐一比对查找。对于性能的影响，HashMap中的链表出现越少越好。</p><h1 id="负载因子与扩容"><a href="#负载因子与扩容" class="headerlink" title="负载因子与扩容"></a>负载因子与扩容</h1><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">//实际存储的key-value键值对的个数</span><br>transient <span class="hljs-type">int</span> size;<br><span class="hljs-comment">//阈值，当table == &#123;&#125;时，该值为初始容量（初始容量默认为16）；</span><br><span class="hljs-type">int</span> threshold;<br><span class="hljs-comment">//负载因子，代表了table的填充度有多少，默认是0.75</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">float</span> loadFactor;<br></code></pre></td></tr></table></figure><p>默认容量：HashMap中数组的长度如果不指定，则默认为16 2的n次幂：HashMap在new的时候可以指定数组长度，但不管如何指定，实际长度一定是2的n次幂（16、32、64、128等），举几个例子，指定长度为17或29，实际长度为32，指定为35、57或63，实际长度为64，以此类推。 扩容：随着散列表存储节点的不断增加，散列表中数组的长度也应该增加，为了保证2的n次幂特性，每次扩容都是当前长度*2， 扩容的方法是，新建一个两倍的数组，然后遍历散列表中的所有节点，重新计算下标放入新数组。 负载因子：由于散列存储下标具有不确定性，在数组即将被占满的时候，后续添加会发生大量冲突，为了避免，需要使数组在即将被占满前就扩容，而不是等待数组被占满。负载因子决定具体何时扩容。其默认值是0.75，可以在调用构造器的时候指定。0.75的意思是，在调用put方法时，算上被put的节点，如果当前数组被占用达到75%则进行扩容。在JDK 1.8进行了优化，红黑树的引入被用于替换链表，上文说到，如果冲突过多，会导致链表过长，降低查询性能，均匀的hash函数能有效的缓解冲突过多，但是并不能完全避免。所以在往链表后追加节点时，如果发现链表长度达到8，就会将链表转为红黑树。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs arcade">final V putVal(int <span class="hljs-built_in">hash</span>, K key, V value, <span class="hljs-built_in">boolean</span> onlyIfAbsent,<br>                   <span class="hljs-built_in">boolean</span> evict) &#123;<br>        Node&lt;K,V&gt;[] <span class="hljs-literal">tab</span>; Node&lt;K,V&gt; p; int n, i;<br>        <span class="hljs-keyword">if</span> ((<span class="hljs-literal">tab</span> = table) == <span class="hljs-literal">null</span> || (n = <span class="hljs-literal">tab</span>.<span class="hljs-built_in">length</span>) == <span class="hljs-number">0</span>)<br>            n = (<span class="hljs-literal">tab</span> = <span class="hljs-built_in">resize</span>()).<span class="hljs-built_in">length</span>;<br>        <span class="hljs-keyword">if</span> ((p = <span class="hljs-literal">tab</span>[i = (n - <span class="hljs-number">1</span>) &amp; <span class="hljs-built_in">hash</span>]) == <span class="hljs-literal">null</span>)<br>            <span class="hljs-literal">tab</span>[i] = newNode(<span class="hljs-built_in">hash</span>, key, value, <span class="hljs-literal">null</span>);<br>        <span class="hljs-keyword">else</span> &#123;<br>            Node&lt;K,V&gt; e; K k;<br>            <span class="hljs-keyword">if</span> (p.<span class="hljs-built_in">hash</span> == <span class="hljs-built_in">hash</span> &amp;&amp;<br>                ((k = p.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.<span class="hljs-built_in">equals</span>(k))))<br>                e = p;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p instanceof TreeNode)<br>                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, <span class="hljs-literal">tab</span>, <span class="hljs-built_in">hash</span>, key, value);<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">for</span> (int binCount = <span class="hljs-number">0</span>; ; ++binCount) &#123;<br>                    <span class="hljs-keyword">if</span> ((e = p.next) == <span class="hljs-literal">null</span>) &#123;<br>                        p.next = newNode(<span class="hljs-built_in">hash</span>, key, value, <span class="hljs-literal">null</span>);<br>                        <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>) <span class="hljs-comment">// -1 for 1st</span><br>                            treeifyBin(<span class="hljs-literal">tab</span>, <span class="hljs-built_in">hash</span>);<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (e.<span class="hljs-built_in">hash</span> == <span class="hljs-built_in">hash</span> &amp;&amp;<br>                        ((k = e.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.<span class="hljs-built_in">equals</span>(k))))<br>                        <span class="hljs-keyword">break</span>;<br>                    p = e;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// existing mapping for key</span><br>                V oldValue = e.value;<br>                <span class="hljs-keyword">if</span> (!onlyIfAbsent || oldValue == <span class="hljs-literal">null</span>)<br>                    e.value = value;<br>                afterNodeAccess(e);<br>                <span class="hljs-keyword">return</span> oldValue;<br>            &#125;<br>        &#125;<br>        ++modCount;<br>        <span class="hljs-keyword">if</span> (++size &gt; threshold)<br>            <span class="hljs-built_in">resize</span>();<br>        afterNodeInsertion(evict);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HashMap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java克隆</title>
    <link href="/article/4a659efd/"/>
    <url>/article/4a659efd/</url>
    
    <content type="html"><![CDATA[<h1 id="Java克隆"><a href="#Java克隆" class="headerlink" title="Java克隆"></a>Java克隆</h1><h3 id="什么是克隆，为什么在编程中使用克隆"><a href="#什么是克隆，为什么在编程中使用克隆" class="headerlink" title="什么是克隆，为什么在编程中使用克隆"></a>什么是克隆，为什么在编程中使用克隆</h3><p>克隆是指创建一个对象的副本，使得新创建的对象在内容上与原始对象相同。在编程中，克隆是常用的技术之一，它具有以下几个重要用途和优势：</p><ol><li>复制对象：使用克隆可以创建一个与原始对象相同的新对象，包括对象的属性和状态。这样可以在不影响原始对象的情况下，对新对象进行修改、操作、传递等。这在某些场景下非常有用，可以避免重新创建和初始化一个对象。</li><li>隔离性与保护：通过克隆，可以创建一个独立于原始对象的副本。这样，修改克隆对象时，不会影响到原始对象，从而实现了对象之间的隔离性。这对于多线程环境下的并发操作或者保护重要数据具有重要意义。</li><li>性能优化：有时候，通过克隆对象可以提高程序的性能。在某些场景下，对象的创建和初始化过程可能较为耗时，如果需要多次使用这个对象，通过克隆原始对象可以避免重复的创建和初始化过程，从而提高程序的执行效率。</li><li>原型模式：克隆在设计模式中有一个重要的角色，即原型模式。原型模式通过克隆来创建对象的实例，而不是使用传统的构造函数。这样可以提供更灵活的对象创建方式，并且避免了频繁的子类化。</li></ol><p>在编程中，通常通过实现Cloneable接口和重写clone方法来实现对象的克隆。然而，需要注意的是克隆操作可能存在深拷贝和浅拷贝的区别，在使用时需要根据实际需求选择合适的克隆方式。</p><h3 id="什么是深拷贝和浅拷贝"><a href="#什么是深拷贝和浅拷贝" class="headerlink" title="什么是深拷贝和浅拷贝"></a>什么是深拷贝和浅拷贝</h3><p>深拷贝（Deep Copy）和浅拷贝（Shallow Copy）是在克隆（Clone）操作中经常遇到的两个概念，它们描述了克隆操作对于对象内部引用的处理方式。</p><ol><li>浅拷贝（Shallow Copy）：<ul><li>浅拷贝指在克隆操作中，只复制对象本身以及对象内部的基本数据类型的属性，而不复制对象内部的引用类型的属性。</li><li>浅拷贝仅仅创建了一个新对象，该对象与原始对象共享对同一引用类型属性的访问。如果原始对象的引用类型属性被修改，浅拷贝的对象也会受到影响。</li><li>在浅拷贝中，新对象和原始对象指向同一块内存区域，因此对其中一个对象进行修改可能会影响到另一个对象。</li></ul></li><li>深拷贝（Deep Copy）：<ul><li>深拷贝指在克隆操作中，除了复制对象本身以及对象内部的基本数据类型的属性外，还要递归地复制对象内部的引用类型的属性。即深度克隆了所有引用类型的属性。</li><li>深拷贝创建了一个完全独立的新对象，该对象与原始对象没有任何关联，对新对象和原始对象的修改互不影响。</li><li>在深拷贝中，新对象和原始对象分别对应不同的内存区域，它们之间不存在引用关系，因此修改其中一个对象不会影响到另一个对象。</li></ul></li></ol><p>为了实现深拷贝，需要对对象内部的引用类型属性进行递归复制。常见的实现深拷贝的方式包括：</p><ul><li>通过序列化和反序列化：将对象序列化为字节流，然后再反序列化为新的对象，这样可以创建一个与原始对象完全独立的副本。</li><li>通过逐个复制引用类型属性：对于每个引用类型的属性，创建一个新的实例并将原始对象属性的内容复制到新的实例中。</li></ul><p>需要注意的是，并非所有对象都能进行深拷贝。某些对象或者类中的属性可能是不可变的，无需拷贝；某些对象可能包含循环引用，无法完全复制。因此，在进行克隆操作时，需要根据具体情况选择合适的拷贝方式。</p><p>深拷贝和浅拷贝的主要区别在于对于对象内部引用类型属性的处理方式。</p><ol><li>数据复制层次的深度：<ul><li>浅拷贝只复制对象本身以及对象内部的基本数据类型的属性，不会递归地复制引用类型的属性。因此，在浅拷贝中，新对象和原始对象共享对同一引用类型属性的访问。</li><li>深拷贝除了复制对象本身和基本数据类型的属性外，还会递归地复制对象内部的引用类型的属性。这样，深拷贝创建了一个完全独立的新对象，与原始对象没有任何关联。</li></ul></li><li>对象之间的关联性：<ul><li>浅拷贝得到的新对象与原始对象共享对同一引用类型属性的访问。如果对其中一个对象的引用类型属性进行修改，另一个对象也会受到影响。</li><li>深拷贝得到的新对象与原始对象没有任何关联，修改其中一个对象的引用类型属性不会影响到另一个对象。</li></ul></li><li>内存区域的分配：<ul><li>在浅拷贝中，新对象和原始对象指向同一块内存区域。因此，对其中一个对象进行修改可能会影响到另一个对象。</li><li>在深拷贝中，新对象和原始对象分别对应不同的内存区域，它们之间不存在引用关系，因此修改其中一个对象不会影响到另一个对象。</li></ul></li></ol><h3 id="浅拷贝示例"><a href="#浅拷贝示例" class="headerlink" title="浅拷贝示例"></a>浅拷贝示例</h3><p>实现 Cloneable 接口和重写 clone() 方法：</p><ul><li>Java 中的 Cloneable 接口是一个标记接口，没有定义任何方法。通过实现 Cloneable 接口并重写 clone() 方法，可以实现对象的浅拷贝。</li><li>在 clone() 方法中，调用父类的 clone() 方法，并将其返回值进行类型转换即可完成浅拷贝。</li></ul><p>下面是一个示例代码，演示了如何使用 Cloneable 接口和 clone() 方法实现浅拷贝：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Cloneable</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.clone();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">person1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">25</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 浅拷贝</span><br>            <span class="hljs-type">Person</span> <span class="hljs-variable">person2</span> <span class="hljs-operator">=</span> (Person) person1.clone();<br><br>            System.out.println(person1.getName() + <span class="hljs-string">&quot; &quot;</span> + person1.getAge()); <span class="hljs-comment">// Alice 25</span><br>            System.out.println(person2.getName() + <span class="hljs-string">&quot; &quot;</span> + person2.getAge()); <span class="hljs-comment">// Alice 25</span><br><br>            person2.setName(<span class="hljs-string">&quot;Bob&quot;</span>);<br>            person2.setAge(<span class="hljs-number">30</span>);<br><br>            System.out.println(person1.getName() + <span class="hljs-string">&quot; &quot;</span> + person1.getAge()); <span class="hljs-comment">// Alice 25</span><br>            System.out.println(person2.getName() + <span class="hljs-string">&quot; &quot;</span> + person2.getAge()); <span class="hljs-comment">// Bob 30</span><br>        &#125; <span class="hljs-keyword">catch</span> (CloneNotSupportedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上述示例中，我们创建了一个 Person 类，并实现了 Cloneable 接口。在 clone() 方法中直接调用了父类的 clone() 方法，并进行了类型转换。通过调用 <code>clone()</code> 方法，可以得到一个新的对象 <code>person2</code>，它与原始对象 <code>person1</code> 具有相同的属性值。当修改 <code>person2</code> 的属性时，不会影响到 <code>person1</code>。</p><h3 id="深拷贝示例"><a href="#深拷贝示例" class="headerlink" title="深拷贝示例"></a>深拷贝示例</h3><p>使用序列化和反序列化：</p><ul><li>将对象写入到字节流中，然后再从字节流中读取出来，这个过程会重新创建一个完全独立的对象，实现了深拷贝。</li><li>为了实现深拷贝，需要将对象及其关联的对象都实现序列化。</li></ul><p>下面是一个示例代码，演示了如何使用序列化和反序列化实现深拷贝：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Address</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br>    <span class="hljs-keyword">private</span> String city;<br>    <span class="hljs-keyword">private</span> String street;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Address</span><span class="hljs-params">(String city, String street)</span> &#123;<br>        <span class="hljs-built_in">this</span>.city = city;<br>        <span class="hljs-built_in">this</span>.street = street;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCity</span><span class="hljs-params">(String city)</span> &#123;<br>        <span class="hljs-built_in">this</span>.city = city;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setStreet</span><span class="hljs-params">(String street)</span> &#123;<br>        <span class="hljs-built_in">this</span>.street = street;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getCity</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> city;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getStreet</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> street;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>    <span class="hljs-keyword">private</span> Address address;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age, Address address)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>        <span class="hljs-built_in">this</span>.address = address;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAddress</span><span class="hljs-params">(Address address)</span> &#123;<br>        <span class="hljs-built_in">this</span>.address = address;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Address <span class="hljs-title function_">getAddress</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> address;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Address</span> <span class="hljs-variable">address</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Address</span>(<span class="hljs-string">&quot;City&quot;</span>, <span class="hljs-string">&quot;Street&quot;</span>);<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">person1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">25</span>, address);<br><br>        <span class="hljs-comment">// 深拷贝</span><br>        <span class="hljs-type">Person</span> <span class="hljs-variable">person2</span> <span class="hljs-operator">=</span> deepCopy(person1);<br><br>        System.out.println(person1.getName() + <span class="hljs-string">&quot; &quot;</span> + person1.getAge() + <span class="hljs-string">&quot; &quot;</span> + person1.getAddress().getCity()); <span class="hljs-comment">// Alice 25 City</span><br>        System.out.println(person2.getName() + <span class="hljs-string">&quot; &quot;</span> + person2.getAge() + <span class="hljs-string">&quot; &quot;</span> + person2.getAddress().getCity()); <span class="hljs-comment">// Alice 25 City</span><br><br>        person2.setName(<span class="hljs-string">&quot;Bob&quot;</span>);<br>        person2.setAge(<span class="hljs-number">30</span>);<br>        person2.getAddress().setCity(<span class="hljs-string">&quot;New City&quot;</span>);<br><br>        System.out.println(person1.getName() + <span class="hljs-string">&quot; &quot;</span> + person1.getAge() + <span class="hljs-string">&quot; &quot;</span> + person1.getAddress().getCity()); <span class="hljs-comment">// Alice 25 City</span><br>        System.out.println(person2.getName() + <span class="hljs-string">&quot; &quot;</span> + person2.getAge() + <span class="hljs-string">&quot; &quot;</span> + person2.getAddress().getCity()); <span class="hljs-comment">// Bob 30 New City</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Serializable</span>&gt; T <span class="hljs-title function_">deepCopy</span><span class="hljs-params">(T object)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">byteArrayOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>            <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">objectOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(byteArrayOutputStream);<br>            objectOutputStream.writeObject(object);<br>            objectOutputStream.flush();<br>            <span class="hljs-type">ByteArrayInputStream</span> <span class="hljs-variable">byteArrayInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayInputStream</span>(byteArrayOutputStream.toByteArray());<br>            <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">objectInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(byteArrayInputStream);<br>            <span class="hljs-keyword">return</span> (T) objectInputStream.readObject();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException | ClassNotFoundException e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上述示例中，我们创建了一个 Address 类和一个 Person 类，它们都实现了 Serializable 接口。通过序列化和反序列化操作，我们可以实现深拷贝。在 <code>deepCopy()</code> 方法中，我们使用字节流将对象写入到内存中，并从内存中读取出来，从而得到一个新的独立对象。通过调用 <code>deepCopy()</code> 方法，可以得到一个新的对象 <code>person2</code>，它与原始对象 <code>person1</code> 完全独立。在修改 <code>person2</code> 的属性时，不会影响到 <code>person1</code>。 值得注意的是，要实现深拷贝，所有相关的类都需要实现 Serializable 接口。</p><h4 id="使用工具类库可以简化对象拷贝的实现过程"><a href="#使用工具类库可以简化对象拷贝的实现过程" class="headerlink" title="使用工具类库可以简化对象拷贝的实现过程"></a>使用工具类库可以简化对象拷贝的实现过程</h4><p><strong>Apache Commons Lang</strong>：Apache Commons Lang是一个常用的Java工具类库，提供了各种实用的方法。其中，<code>SerializationUtils</code>类提供了对象的深拷贝功能。</p><p>请确保在项目中引入Apache Commons Lang库。下面是使用<code>SerializationUtils</code>进行对象拷贝的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.apache.commons.lang3.SerializationUtils;<br><span class="hljs-type">MyClass</span> <span class="hljs-variable">original</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>();<br><span class="hljs-comment">// 设置original对象的属性</span><br><span class="hljs-type">MyClass</span> <span class="hljs-variable">cloned</span> <span class="hljs-operator">=</span> SerializationUtils.clone(original); <span class="hljs-comment">// 创建深拷贝副本</span><br></code></pre></td></tr></table></figure><p><code>SerializationUtils.clone()</code>方法将会执行对象的序列化和反序列化操作，从而实现深拷贝。</p><p><strong>Gson</strong>：Gson是Google提供的一个用于处理JSON的Java库，它也可以用于对象的深拷贝。通过将对象转换为JSON字符串，然后将JSON字符串转换回对象，可以实现深拷贝的效果。</p><p>请确保在项目中引入Gson库。下面是使用Gson进行对象拷贝的示例：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">import com.google.gson.Gson;<br>MyClass original = <span class="hljs-keyword">new</span> <span class="hljs-constructor">MyClass()</span>;<br><span class="hljs-comment">// 设置original对象的属性</span><br>Gson gson = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Gson()</span>;<br>MyClass cloned = gson.from<span class="hljs-constructor">Json(<span class="hljs-params">gson</span>.<span class="hljs-params">toJson</span>(<span class="hljs-params">original</span>)</span>, <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">MyClass</span>.</span></span><span class="hljs-keyword">class</span>); <span class="hljs-comment">// 创建深拷贝副本</span><br></code></pre></td></tr></table></figure><p><code>gson.toJson()</code>将对象转换为JSON字符串，而<code>gson.fromJson()</code>将JSON字符串转换回对象。通过这两个方法的组合，可以实现对象的深拷贝。</p><h3 id="深拷贝和浅拷贝的区别"><a href="#深拷贝和浅拷贝的区别" class="headerlink" title="深拷贝和浅拷贝的区别"></a>深拷贝和浅拷贝的区别</h3><p>深拷贝（Deep Copy）：</p><ol><li>适用场景：<ul><li>当源对象包含引用类型的属性时，如果需要复制对象及其子对象的所有属性，而不仅仅只是复制引用，就需要使用深拷贝。</li><li>当希望修改副本对象的属性不影响原始对象时，需要使用深拷贝。</li></ul></li><li>工作原理：<ul><li>深拷贝将源对象及其关联的全部对象进行递归复制，每个对象都拥有独立的内存空间，修改副本对象不会影响原始对象。</li></ul></li><li>实现方式：<ul><li>使用递归或者拷贝构造函数来复制对象及其子对象的属性。</li></ul></li><li>示例场景：<ul><li>复制复杂对象的副本，使其成为独立的个体，例如：拷贝一个包含集合、嵌套对象等的数据结构。</li><li>对象图的克隆，当原对象包含子对象，并且对子对象的修改不应该影响原对象时。</li></ul></li></ol><p>浅拷贝（Shallow Copy）：</p><ol><li>适用场景：<ul><li>当源对象的属性全为基本数据类型或者不可变对象，并且不需要复制引用类型的属性时，可以使用浅拷贝。</li><li>当希望修改副本对象的属性同时影响原始对象时，可以使用浅拷贝。</li></ul></li><li>工作原理：<ul><li>浅拷贝只复制对象及其引用，而不复制引用指向的实际对象，新旧对象将共享同一个引用对象。修改副本对象会影响原始对象。</li></ul></li><li>实现方式：<ul><li>通常使用对象的 <code>clone()</code> 方法来进行浅拷贝。</li></ul></li><li>示例场景：<ul><li>快速创建对象副本，以便在某些操作中对其进行修改，同时保留原始对象。</li><li>在某些情况下，共享一部分数据以节省内存和提高性能。</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java克隆</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java异常</title>
    <link href="/article/f495a96f/"/>
    <url>/article/f495a96f/</url>
    
    <content type="html"><![CDATA[<blockquote><p>异常处理机制就是当程序发生异常时，它强制终止程序运行，记录异常信息并将这些信息反馈给我们，由我们来确定是否处理异常。</p></blockquote><h2 id="Java异常知识汇总"><a href="#Java异常知识汇总" class="headerlink" title="Java异常知识汇总"></a>Java异常知识汇总</h2><h3 id="什么是异常"><a href="#什么是异常" class="headerlink" title="什么是异常"></a>什么是异常</h3><p>软件程序在运行过程中，非常可能遇到一些问题(比如：你的程序要打开某个文件，这个文件可能不存在或者文件格式不对；你要读取数据库的数据，数据可能为空等等)，我们叫异常。英文名是：<strong>Exception</strong>，意思是：例外。</p><p>简单分类：</p><ul><li>检查性异常：最具代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的。例如要打开一个不存在的文件时，一个异常就发生了，这些异常在编译时不能被简单地忽略。</li><li>运行时异常：运行时异常是可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略。</li><li>错误ERROR：错误不是异常，而是脱离程序员控制的问题。错误在代码中通常被忽略。例如，当栈溢出时，一个错误就发生了，它们在编译也检查不到的。</li></ul><h4 id="Error："><a href="#Error：" class="headerlink" title="Error："></a>Error：</h4><ul><li>Error类对象是由Java虚拟机生成并抛出，大多数错误与代码编写者所执行的操作无关。</li><li>Java虚拟机运行错误(Virtual MachineError),当JVM不再有继续执行操作所需的内存资源时，将出现<strong>OutOfMemoryError</strong>。这些异常发生时，Java虚拟机(JVM)一般会选择线程终止。</li><li>还有发生在虚拟机试图执行应用时，如类定义错误(NoClassDefFoundError)、链接错误(LinkageError)。这些错误是不可查的，因为它们在应用程序的控制和处理功能之外，而且绝大多数是程序运行时不允许出现的状况。</li></ul><h4 id="Exception"><a href="#Exception" class="headerlink" title="Exception:"></a>Exception:</h4><ul><li>在Exception分支中有一个重要的子类RuntimeException(运行时异常)<ul><li>ArrayIndexOutOfBoundsException(数组下标越界异常)</li><li>NullPointerException(空指针异常)</li><li>ArithmeticException(算术异常)</li><li>MissingResourceException(丢失资源异常)</li><li>ClassNotFoundException(找不到类)等异常</li></ul></li><li>这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生</li></ul><p>Error和Exception的区别：Error通常是灾难性的、致命的错误，是程序无法控制和处理的，当出现这些异常时。java虚拟机(JVM)一般会选择终止线程；Exception通常情况下是可以被程序处理的，并且在程序中应该因可能的去处理这些异常。</p><h4 id="异常体系结构"><a href="#异常体系结构" class="headerlink" title="异常体系结构"></a>异常体系结构</h4><p>Java把异常当作对象来处理，并定义了一个基类<strong>java.lang.Throwable</strong>作为所有异常的超类。</p><p>在Java API中已经定义了许多异常类，这些异常类分为两大类，错误Error和异常Exception。</p><h3 id="异常处理机制"><a href="#异常处理机制" class="headerlink" title="异常处理机制"></a>异常处理机制</h3><p>异常处理的五个关键字：try、catch、finally throw、throws</p><h4 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h4><p>用到try catch finallycatch可以写多个来捕获 如果不确定具体的什么异常，可以加一个catch(Exception)（最大的异常类）</p><p>快捷键写try_catch_finally：选中需要监视异常的语句，<strong>Ctrl+Alt+t</strong> 即可包裹住</p><h4 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h4><p>用 throw和throws 一般是在方法中使用</p><h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><p>使用Java内置的异常类可以描述在编程时遇到的大部分异常情况。除此之外，用户还可以自定义异常。用户自定义异常，只需要继承Exception类即可。</p><p>在程序中使用自定义异常类，大体可分为以下几个步骤：</p><ul><li>1.创建自定义异常类</li><li>2.在方法中通过throw关键中抛出异常对象</li><li>3.如果在当前抛出异常的方法中处理异常，可以使用try_catch语句捕捉并处理，也可以在方法的声明处通过throws关键字指明要抛出给方法调用者的异常，继续进行下一步操作</li><li>4.在出现异常方法的调用者中捕获并处理异常</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Java异常</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java集合</title>
    <link href="/article/21084/"/>
    <url>/article/21084/</url>
    
    <content type="html"><![CDATA[<p>Java集合框架是Java开发中非常重要的一部分，它提供了一组用于存储和操作数据的类和接口。在本文中，我们将深入探讨Java集合框架的核心概念和使用方法，并且探讨Java集合框架的不同类型以及它们的应用场景。</p><h2 id="Java集合框架概述"><a href="#Java集合框架概述" class="headerlink" title="Java集合框架概述"></a>Java集合框架概述</h2><p>Java集合框架是Java提供的一个用于存储和操作对象的类库。它包含了一组通用的接口和类，可以用来表示不同类型的数据结构。Java集合框架的核心接口包括Collection、List、Set、Map和Queue等。这些接口定义了不同类型的集合，提供了一组通用的方法，可以用来添加、删除、查找和遍历集合中的元素。</p><p>Java集合框架的设计目标是提供一组通用的数据结构，可以用来存储和操作不同类型的对象。它的优点在于可以提高代码的可读性和可维护性，减少代码的冗余性和错误性。Java集合框架的实现也是非常高效和灵活的，可以满足不同类型的应用程序的需求。</p><h3 id="List集合"><a href="#List集合" class="headerlink" title="List集合"></a>List集合</h3><p>List是一个有序的集合，它可以包含重复的元素。List集合提供了一组通用的方法，可以用来添加、删除、查找和遍历集合中的元素。List集合通常用于需要保持元素顺序的场景，例如列表、排行榜等。</p><p>Java集合框架提供了两种常用的List实现：ArrayList和LinkedList。ArrayList是一个基于数组的实现，它可以随机访问元素，并且支持高效的添加和删除操作。LinkedList是一个基于链表的实现，它支持高效的插入和删除操作，但是访问元素的效率较低。</p><p>以下是一个使用ArrayList实现的简单示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayListDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建一个ArrayList对象</span><br>        List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>        <span class="hljs-comment">// 添加元素</span><br>        list.add(<span class="hljs-string">&quot;apple&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;banana&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;orange&quot;</span>);<br><br>        <span class="hljs-comment">// 遍历元素</span><br>        <span class="hljs-keyword">for</span> (String item : list) &#123;<br>            System.out.println(item);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Set集合"><a href="#Set集合" class="headerlink" title="Set集合"></a>Set集合</h3><p>Set是一个无序的集合，它不允许包含重复的元素。Set集合通常用于需要去重的场景，例如统计网站访问量、统计用户活跃度等。</p><p>Java集合框架提供了两种常用的Set实现：HashSet和TreeSet。HashSet是一个基于哈希表的实现，它支持高效的添加、删除和查找操作，但是不保证元素的顺序。TreeSet是一个基于红黑树的实现，它可以保证元素的有序性，并且支持高效的查找操作。</p><p>以下是一个使用HashSet实现的简单示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.HashSet;<br><span class="hljs-keyword">import</span> java.util.Set;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HashSetDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建一个HashSet对象</span><br>        Set&lt;String&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br><br>        <span class="hljs-comment">// 添加元素</span><br>        set.add(<span class="hljs-string">&quot;apple&quot;</span>);<br>        set.add(<span class="hljs-string">&quot;banana&quot;</span>);<br>        set.add(<span class="hljs-string">&quot;orange&quot;</span>);<br>        set.add(<span class="hljs-string">&quot;apple&quot;</span>);<br><br>        <span class="hljs-comment">// 遍历元素</span><br>        <span class="hljs-keyword">for</span> (String item : set) &#123;<br>            System.out.println(item);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Map集合"><a href="#Map集合" class="headerlink" title="Map集合"></a>Map集合</h3><p>Map是一个键值对的集合，它可以用来存储对象之间的映射关系。Map集合通常用于需要根据键来查找值的场景，例如字典、配置文件等。</p><p>Java集合框架提供了两种常用的Map实现：HashMap和TreeMap。HashMap是一个基于哈希表的实现，它支持高效的添加、删除和查找操作，但是不保证键值对的顺序。TreeMap是一个基于红黑树的实现，它可以保证键值对的有序性，并且支持高效的查找操作。</p><p>以下是一个使用HashMap实现的简单示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HashMapDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建一个HashMap对象</span><br>        Map&lt;String, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>        <span class="hljs-comment">// 添加键值对</span><br>        map.put(<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-number">1</span>);<br>        map.put(<span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-number">2</span>);<br>        map.put(<span class="hljs-string">&quot;orange&quot;</span>, <span class="hljs-number">3</span>);<br><br>        <span class="hljs-comment">// 根据键查找值</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> map.get(<span class="hljs-string">&quot;apple&quot;</span>);<br>        System.out.println(value);<br><br>        <span class="hljs-comment">// 遍历键值对</span><br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) &#123;<br>            System.out.println(entry.getKey() + <span class="hljs-string">&quot;: &quot;</span> + entry.getValue());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Queue集合"><a href="#Queue集合" class="headerlink" title="Queue集合"></a>Queue集合</h3><p>Queue是一个队列集合，它通常用于实现先进先出（FIFO）的逻辑。Queue集合提供了一组通用的方法，可以用来添加、删除和获取队列中的元素。</p><p>Java集合框架提供了两种常用的Queue实现：LinkedList和PriorityQueue。LinkedList可以用作队列的实现，但是效率较低。PriorityQueue是一个基于堆的实现，它可以实现按照元素优先级的顺序进行插入和删除操作。</p><p>以下是一个使用LinkedList实现的简单示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.LinkedList;<br><span class="hljs-keyword">import</span> java.util.Queue;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedListDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建一个LinkedList对象</span><br>        Queue&lt;String&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br>        <span class="hljs-comment">// 添加元素</span><br>        queue.add(<span class="hljs-string">&quot;apple&quot;</span>);<br>        queue.add(<span class="hljs-string">&quot;banana&quot;</span>);<br>        queue.add(<span class="hljs-string">&quot;orange&quot;</span>);<br><br>        <span class="hljs-comment">// 获取队首元素</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> queue.peek();<br>        System.out.println(first);<br><br>        <span class="hljs-comment">// 删除队首元素</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">removed</span> <span class="hljs-operator">=</span> queue.remove();<br>        System.out.println(removed);<br><br>        <span class="hljs-comment">// 遍历元素</span><br>        <span class="hljs-keyword">for</span> (String item : queue) &#123;<br>            System.out.println(item);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java集合</tag>
      
    </tags>
    
  </entry>
  
  
  
  
  
  
  <entry>
    <title>about</title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[<h1 id="About-Me"><a href="#About-Me" class="headerlink" title="About Me"></a>About Me</h1><ul><li>后端开发工程师（Java）</li><li>南昌航空大学</li><li>软件工程（24届）</li><li>热爱编程，喜欢接触新技术</li><li>音乐</li><li>羽毛球</li><li>保持生活节奏的平衡</li><li>成功的秘诀在于对目标的专注和持久的努力</li><li>真正的力量来自于内心的善良和慈悲</li></ul><p>在我的博客上，您可以找到关于我的技术博客、生活日常的文章。如果您对我的文章或者我的工作感兴趣，欢迎与我联系，我会非常乐意和您交流。</p><h2 id="记录博客的初衷"><a href="#记录博客的初衷" class="headerlink" title="记录博客的初衷"></a>记录博客的初衷</h2><ul><li>我希望能够在学习过程中记录笔记，以便日后复习和回顾。通过将重要的概念、知识点和关键信息记录下来，我可以更好地巩固所学内容。</li><li>学习过程中，我计划将一些技术教程分享出来，与其他人进行讨论和交流，这样可以帮助我更好地理解教程，并为其他人提供帮助和解答疑惑。</li><li>我希望能够分享一些有价值的开发学习资源，如书籍、教程、博客等，通过这些分享，我希望能够为开发人员提供更多的帮助和支持。</li></ul><h2 id="技术专题"><a href="#技术专题" class="headerlink" title="技术专题"></a>技术专题</h2><ul><li><p>Java基础：Java集合</p></li><li><p>Java并发：Java 并发编程</p></li><li><p>JVM：Java 虚拟机</p></li><li><p>Spring： Web 开发框架</p></li><li><p>Redis：分布式缓存</p></li><li><p>ZooKeeper：分布式系统协作的中间件</p></li><li><p>Kafka：消息队列</p></li><li><p>MySQL：数据库</p></li><li><p>Docker：容器平台</p></li><li><p>Nginx：流量网关，反向代理</p></li><li><p>Linux：Linux 操作系统下，常见问题和操作</p></li><li><p>ElasticSearch：分布式搜索中心 </p></li><li><p>Flume：日志收集组件 </p></li><li><p>Storm：准实时数据处理 </p></li><li><p>Ganglia：系统监控</p></li><li><p>HTTP：网络协议</p></li><li><p>其他</p></li></ul><h2 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h2><p>邮箱：<a href="mailto:&#x32;&#54;&#x39;&#51;&#x35;&#54;&#x37;&#52;&#x34;&#48;&#x40;&#113;&#113;&#x2e;&#x63;&#x6f;&#x6d;">&#x32;&#54;&#x39;&#51;&#x35;&#54;&#x37;&#52;&#x34;&#48;&#x40;&#113;&#113;&#x2e;&#x63;&#x6f;&#x6d;</a></p><p>QQ：2693567440 </p><hr><img src="https://www.helloimg.com/images/2023/08/16/oS3zGq.png" alt="Github chart" />]]></content>
    
  </entry>
  
  
  
</search>
